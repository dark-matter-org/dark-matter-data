#summary Describes the Dark Matter Object naming concept.

<wiki:toc />

= The Naming of Dark Matter Objects =

Object naming is a crucial aspect of [DMOOverview DMOs] and this page gives you an overview of what you need to know.

== Object Identification is Application Specific ==

This is probably an obvious generality, but it has a big impact on any framework that labels itself as flexible or extensible; and Dark Matter would like to label itself as both!

Often, framework or infrastructure projects take the easy way out by indicating that object names can be Integers or Strings, and while any object naming scheme is likely representable as a String, that doesn't make it easy to take advantage of the information that can actually be embedded in the name. You'll often see utility classes or methods that are designed to pull apart names to get at that additional information, but if you're dealing with a set of heterogeneous objects that have different naming mechanisms, this approach can be error prone and messy.

So what's a framework designer to do?

== Make Names a Distinct Type: `DmcObjectName` ==

Dark Matter approaches this issue by defining a base type from which all forms of object names are derived, [http://code.google.com/p/dark-matter-data/source/browse/trunk/%20dark-matter-data/dark-matter-data/src/org/dmd/dmc/DmcObjectName.java DmcObjectName].

Now at first, this may seem restrictive, but because your derived type can take any form you need it to and because you are free to mix different name types together in the same application, you have ultimate freedom. If you want straight String or Integer names, the built in `StringName` and `IntegerName` types have you covered. If you want names based on [http://en.wikipedia.org/wiki/Universally_unique_identifier UUIDs], you can use the `UUIDName` type.

However, lets says you want to represent containment hierarchy in your names and provide methods to traverse the hierarchy; well, you can do that by deriving from `DmcHierarchicObjectName` and providing the functionality you need to make it happen.

A variety of [http://code.google.com/p/dark-matter-data/wiki/DMSTypeDefinition#Name_Types built in name types] have been defined.

== Defining Named Objects in the Dark Matter Schema ==

Dark Matter Objects can be named, or not, it depends on how you intend to use them. If an object class is going to have a name, you indicate this via its [DMSClassDefinition ClassDefinition] as follows:

{{{
ClassDefinition
name      Stock
isNamedBy isinName
must      isinName
...
}}}

The `isNamedBy` attribute is a reference to an [DMSAttributeDefinition AttributeDefinition], `isinName`. All naming attributes are special. Why and how they are special is discussed in the [#Defining_Your_Own_Name_Types Defining Your Own Name Types] section.

For now, it's enough to understand that there's a "must have" attribute called `isinName` that will uniquely identify instances of the `Stock` class.

By the way ISIN refers to the [http://en.wikipedia.org/wiki/International_Securities_Identification_Number International Securities Identification Number] of things like bonds, stocks etc.

== `isNamedBy` and Named Object References ==

By specifying that your class `isNamedBy` an attribute, you trigger some additional code generation in Dark Matter. It results in the creation of a DmcNamedObjectREF derivative, which is a base type that allows you to easily define references between objects. These references can exist in both resolved and unresolved states i.e. if they are resolved, you can immediately access the object that is referred to. When the reference is unresolved, it contains just the name of the object to which it's referring.

== Name Support in the Dark Matter Protocol == 

The primary message types associated with the [DMPOverview Dark Matter Protocol] are based on the use of named objects. Likewise, the [DMPEvent DMPEvent] contains a `source` attribute that indicates the name of the object that caused a particular event.

So, if you intend to use the [DMPOverview Dark Matter Protocol] you will become very familiar with object naming.

== Defining Your Own Name Types ==

Defining your own name types is fairly straight forward, but there are a few steps you have to follow to make it all fit together.

<table width="820">

<tr>
<td width="20" valign="top">
*1.*
</td>
<td valign="top">
Define your primitive name type (see [http://code.google.com/p/dark-matter-data/source/browse/trunk/%20dark-matter-data/dark-matter-data/src/org/dmd/dmc/types/IntegerName.java IntegerName] for a simple example).

The important aspects to note are that you must derive from `DmcObjectName` and implement `Serializable` for example:

{{{
public class MyName extends DmcObjectName implements Serializable {

    // You will need this to pass back from the getNameClass() function
    // which is required by DmcObjectName
    public final static String className = "MyName";

    // storage for whatever bits you need to store your name
 
    // Don't forget your zero arg constructor!
    public MyName(){
    }

    // You should be able to instantiate your name from whatever
    // basic bits you use to represent it
    public MyName(args){
       ...
    }

    // A clone constructor is useful to have 
    public MyName(MyName original){
       ...
    }

    // And then there will be a bunch of overridden methods to satisfy DmcObjectName

}
}}}

</td>
</tr>

<tr>
<td valign="top">
*2.*
</td>
<td valign="top">
Define your `DmcTypeMyName` object. Again, see the [http://code.google.com/p/dark-matter-data/source/browse/trunk/%20dark-matter-data/dark-matter-data/src/org/dmd/dmc/types/DmcTypeIntegerName.java DmcTypeIntegerName.java] for a simple example.

</td>
</tr>

<tr>
<td valign="top">
*3.*
</td>
<td valign="top">
Add the new type to your [DMSOverview Dark Matter Schema] type definitions. The definition will resemble the following:

{{{
TypeDefinition
name		MyName
typeClassName	com.mine.types.DmcTypeMyName
primitiveType	com.mine.types.MyName
isNameType	true
description     The MyName type is specially designed to name my things!
}}}
</td>
</tr>

<tr>
<td valign="top">
*4.*
</td>
<td valign="top">
And finally, create the attribute that you will use in your `isNamedBy` attribute on classes that are named by this name type:

{{{
AttributeDefinition
name                    myName
dmdID		        2
type                    MyName
designatedNameAttribute true
description             The myName attribute is used to name my things!
}}}
</td>
</tr>

</table>