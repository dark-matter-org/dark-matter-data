#summary Describes the Dark Matter Object naming concept.

<wiki:toc />

= The Naming of Dark Matter Objects =

Object naming is a crucial aspect of [DMOOverview DMOs] and this page gives you an overview of what you need to know.

== Object Identification is Application Specific ==

This is probably an obvious generality, but it has a big impact on any framework that labels itself as flexible or extensible; and Dark Matter would like to label itself as both!

Often, framework or infrastructure projects take the easy way out by indicating that object names can be Integers or Strings, and while any object naming scheme is likely representable as a String, that doesn't make it easy to take advantage of the information that can actually be embedded in the name. You'll often see utility classes or methods that are designed to pull apart names to get at that additional information, but if you're dealing with a set of heterogeneous objects that have different naming mechanisms, this approach can be error prone and messy.

So what's a framework designer to do?

== Make Names a Distinct Type: `DmcObjectName` ==

Dark Matter approaches this issue by defining a base type from which all forms of object names are derived, [http://code.google.com/p/dark-matter-data/source/browse/trunk/%20dark-matter-data/dark-matter-data/src/org/dmd/dmc/DmcObjectName.java DmcObjectName].

Now at first, this may seem restrictive, but because your derived type can take any form you need it to and because you are free to mix different name types together in the same application, you have ultimate freedom. If you want straight String or Integer names, the built in `StringName` and `IntegerName` types have you covered. If you want names based on [http://en.wikipedia.org/wiki/Universally_unique_identifier UUIDs], you can use the `UUIDName` type.

However, lets says you want to represent containment hierarchy in your names and provide methods to traverse the hierarchy; well, you can do that by deriving from `DmcHierarchicObjectName` and providing the functionality you need to make it happen.

== Defining Named Objects in the Dark Matter Schema ==

Dark Matter Objects can be named, or not, it depends on how you intend to use them. If an object class is going to have a name, you indicate this via its [DMSClassDefinition ClassDefinition] as follows:

{{{
ClassDefinition
name      Stock
isNamedBy isinName
must      isinName
...
}}}

The `isNamedBy` attribute is a reference to an [DMSAttributeDefinition AttributeDefinition], `isinName`. All naming attributes are special. Why and how they are special is discussed in the [#Defining_Your_Own_Name_Types Defining Your Own Name Types] section.

For now, it's enough to understand that there's a "must have" attribute called `isinName` that will uniquely identify instances of the `Stock` class.

By the way ISIN refers to the [http://en.wikipedia.org/wiki/International_Securities_Identification_Number International Securities Identification Number] of things like bonds, stocks etc.

== `isNamedBy` and Named Object References ==

By specifying that your class `isNamedBy` an attribute, you trigger some additional code generation in Dark Matter. It results in the creation of a DmcNamedObjectREF derivative, which is a base type that allows you to easily define references between objects. These references can exist in both resolved and unresolved states i.e. if they are resolved, you can immediately access the object that is referred to. When the reference is unresolved, it contains just the name of the object to which it's referring.

== Name Support in the Dark Matter Protocol == 

The primary message types associated with the [DMPOverview Dark Matter Protocol] are based on the use of named objects. Likewise, the [DMPEvent DMPEvent] contains a `source` attribute that indicates the name of the object that caused a particular event.

So, if you intend to use the [DMPOverview Dark Matter Protocol] you will become very familiar with object naming.

== Defining Your Own Name Types ==

Defining your own name types is fairly straight forward, but there are a few steps you have to follow to make it all fit together.

1. Define your 