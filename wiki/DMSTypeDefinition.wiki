#summary The Dark Matter Schema TypeDefinition

<wiki:toc />

= Type Definitions =


The `TypeDefinition` forms the heart of all data representation in Dark Matter and, whether or not you need to define your own types, deserves a bit of your attention. If you don't give a rat's ass about implementation related stuff, jump straight to the [WikiSyntax#Built_in_Types Built in Types] section.



== Built in Types ==

The following types are defined as part of the Dark Matter metaschema.


=== Basic Types ===

These should be pretty self explanatory.

<table width="820">
<tr>
<td> *Boolean* </td>
<td> `java.lang.Boolean` </td>
</tr>

<tr>
<td> *Date* </td>
<td> `java.lang.Date` </td>
</tr>

<tr>
<td> *Double* </td>
<td> `java.lang.Double` </td>
</tr>

<tr>
<td> *Float* </td>
<td> `java.lang.Float` </td>
</tr>

<tr>
<td> *Integer* </td>
<td> `java.lang.Integer` </td>
</tr>

<tr>
<td> *Long* </td>
<td> `java.lang.Long` </td>
</tr>

<tr>
<td width="220"> *String* </td>
<td> `java.lang.String` </td>
</tr>

</table>

----
=== Other Primitive Types ===

This section lists some types that are primitive in nature and used to support various various capabilities within the Dark Matter Framework. Many of these types are pretty esoteric, so don't worry if the reason for the type escapes you!
<table width="820">

<tr>
<td width="220" valign="top"> *`DmcObject`* </td>
<td valign="top"> `org.dmd.dmc.DmcObject`

When you want to hold values which are [DMOOverview DMOs] themselves, you use the `DmcObject` type. This is used in places like the [DMPGetRequest DMP Get Response] object to return a set of objects.
</td>
</tr>

<tr>
<td valign="top"> *`Modifier`* </td>
<td valign="top"> `org.dmd.dmc.type.Modifier`

One of the more interesting aspects of [DMOOverview DMOs] is that they allow for recording of the changes that you make to them. Any operation that you can perform against the collection of attributes in a [DMOOverview DMO] can be represented by a `Modifier`. See the [DMPSetRequest Set Request] page for examples of how this type (used for the `modify` attribute.
</td>
</tr>

<tr>
<td valign="top"> *`NameContainer`* </td>
<td valign="top"> `org.dmd.dmc.types.NameContainer`

As discussed on the [DMONaming DMO Naming] page, [Name_Types Name Types] are specialized types that represent the names of [DMOOverview DMOs]. When the names of things are transported, they have to maintain their identity because the actual implementation of the name is type specific. The `NameContainer` type provides this mechanism for holding a self described object name.

As I said, some of these types are pretty esoteric, so if none of that made sense, check out places where the `NameContainer` type is used e.g. in [DMPOverview Dark Matter Protocol] requests for the `target` attribute and for the `source` attribute in [DMPEvent DMP Events].
</td>
</tr>

</table>

----
=== Graphing/Plotting Types ===

Displaying data in charts is a fairly common operation in many applications and it's good to have some types that facilitate this activity.

<table width="820">

<tr>
<td width="220" valign="top"> *`LabelledIntegerDataPoint`* </td>
<td valign="top"> `org.dmd.dmc.types.LabelledIntegerDataPoint`

Need to populate a [http://code.google.com/apis/visualization/documentation/gallery/piechart.html Pie Chart]? Then request a series of LabelledIntegerDataPoints. This is simple a label string followed by an integer value. A multi-valued attribute of this type called data series,might appear as follows in OIF form:
{{{
dataSeries  Work 11
dataSeries  Eat 2
dataSeries  Commute 2
dataSeries  Watch TV 2
dataSeries  Sleep 7
}}}
</td>
</tr>

<tr>
<td valign="top"> *`TimeDoubleDataPoint`* </td>
<td valign="top"> `org.dmd.dmc.types.TimeDoubleDataPoint`

Need to plot a series of values over time? The `TimeDoubleDataPoint` may be what you need. This type is very handy as well for providing ongoing updates to a chart since values may be removed from the trailing edge of the data series and added to leading edge. 
</td>
</tr>

</table>

----
=== Name Types ===

[DMONaming DMO Naming] is a fundamental concept in Dark Matter and, since naming is very application specific, these types are merely examples of naming mechanisms. All values associated name types must be derived from the [http://code.google.com/p/dark-matter-data/source/browse/trunk/%20dark-matter-data/dark-matter-data/src/org/dmd/dmc/DmcObjectName.java DmcObjectName] class which provides a standard interface for all names.

Another standard base for naming is the `DmcHierarchicObjectName`. This is derived from `DmcObjectName` and adds the concept of being able to get the name of a parent object. This is especially useful when representing hierarchic data relationships.

<table width="820">

<tr>
<td valign="top"> *`DotName`* </td>
<td valign="top"> `org.dmd.dmc.types.DotName` derived from `DmcHierarchicObjectName`

Dot names are a fairly common naming mechanism that includes hierarchy in the structure of a name. The `DotName` type lets you easily represent names of this type. If you a name of the form `grandparent.parent.child`, calling `getParentName()` will return `grandparent.parent`, as you might expect.
</td>
</tr>
<tr>
<td valign="top"> *`IntegerName`* </td>
<td valign="top"> `org.dmd.dmc.types.IntegerName` derived from `DmcObjectName`

If you just need things numerically identified, the `IntegerName` may fit your needs. Nothing complex, just an Integer.
</td>
</tr>
<tr>
<td width="220" valign="top"> *`StringName`* </td>
<td valign="top"> `org.dmd.dmc.types.StringName` derived from `DmcObjectName`

At base, the `StringName` is just a String. It used as the basic naming mechanism for schema definitions and a variety of other configuration definitions.
</td>
</tr>
<tr>
<td valign="top"> *`UUIDName`* </td>
<td valign="top"> `org.dmd.dmc.types.UUIDName` derived from `DmcObjectName`

A common mechanism for uniquely naming objects is using [http://en.wikipedia.org/wiki/Universally_unique_identifier UUIDs]. The `UUIDName` provides this mechanism in a GWT friendly way by using the `UUIDLite` type as its basis. 
</td>
</tr>
</table>

----
=== Mapped Types ===

Mapped types are required if you want to create `HASHMAP` or 'TREEMAP` attributes. All mapped types implement the `DmcMappedAttributeIF` interface which allows the Dark Matter infrastructure to retrieve the key for a particular value.

All [DMONaming DMO Names] are mapped types since `DmcObjectName` implements the `DmcMappedAttributeIF`.

All [DMOReferences DMO Object References], which are generated automatically for named objects as part of the [DMOGenerator DMO Generation Process] also implement this interface so that they can be stored in `MAPPED` attributes. 

<table>

<tr>
<td width="220" valign="top"> *`IntegerToBoolean`* </td>
<td valign="top"> `org.dmd.dmc.types.IntegerToBoolean` implements `DmcMappedAttributeIF`
</td>
</tr>

<tr>
<td valign="top"> *`IntegerToString`* </td>
<td valign="top"> `org.dmd.dmc.types.IntegerToString` implements `DmcMappedAttributeIF`
</td>
</tr>

<tr>
<td valign="top"> *`IntegerToUUIDLite`* </td>
<td valign="top"> `org.dmd.dmc.types.IntegerToUUIDLite` implements `DmcMappedAttributeIF `
</td>
</tr>

</table>

== Defining Your Own Types ==

Defining your own types is a fairly straightforward exercise and involves 3 steps:

<table width="820">

<tr>
<td width="20" valign="top">
*1.*
</td>
<td valign="top">
Create your value container/primitive type.

<font color="#9E0B0F>
*All aspects of your type must conform to the [http://code.google.com/webtoolkit/doc/2.2/RefJreEmulation.html JRE Emulation] guidlelines.*
</font>

A decent example of a non-trivial type is the [http://code.google.com/p/dark-matter-data/source/browse/trunk/%20dark-matter-data/dark-matter-data/src/org/dmd/dmc/types/UUIDLite.java UUIDLite] which just allows for use of UUIDs in a GWT context.

The basic parts you need:

{{{
// There's nothing special about the value container, but
// it's good form to mark it as Serializable
public class MyType extends implements Serializable {

    // storage for whatever bits you need to store your type
 
    // Don't forget your zero arg constructor!
    public MyType(){
    }

    // You should be able to instantiate your type from whatever
    // basic bits you use to represent it
    public MyType(args){
       ...
    }

    // A clone constructor is useful to have 
    public MyType(MyType original){
       ...
    }

    // A constructor that takes a String is useful, since all types must
    // be representable as Strings and parsable from Strings. If the 
    // String contents don't satisfy you, throw an exception!
    public MyType(String value) throws DmcValueException {
        ...
    }

    // On the String theme - you should override toString() to produce
    // the appropriate String representation of your type
    @Override
    public String toString(){
        ...
    }

    // Not explicitly required, but useful
    public int compareTo(Object obj) {
    }

    // Likewise, not explicitly required but useful
    @Override
    public boolean equals(Object object) {
    }

    // Support for serializing the type: see the Serialization page
    public void serializeIt(DmcOutputStreamIF dos) throws Exception {
        ...
    }

    // Support for deserializing the type: see the Serialization page
    public void deserializeIt(DmcInputStreamIF dis) throws Exception {
        ...
    }

}
}}}

Most of the aspects here are for the convenience of the enclosing `DmcType` described in the next section.

The [DMOSerialization Serialization] mechanisms are pretty straightforward and allow you to focus just on your little piece of the world i.e. the type you'll be serializing. The overall serialization/deserialization mechanism of complete objects is handled for you automatically by the Dark Matter Core classes.
</td>
</tr>

<tr>
<td valign="top">
*2.*
</td>
<td valign="top">
Define your `DmcTypeMyType` class. Although you can name this class anything you like, the convention is to call it `DmcType[value container type]`.

Another convention is that you define your types in a separate `types` folder in your shared code folder (since types are a shared resource). This makes it fairly clear where your `type` related code lives.

{{{
src
    com
        example
            client
            server
            shared
                dmdconfig
                    v0dot1
                       myschema.dms
                types
                    DmcTypeMyType.java
                    MyType.java

}}}

All `DmcType` implementations are derived from the parameterized base type `DmcAttribute` and are `abstract`.

Your class definition will appear as follows:

{{{
@SuppressWarnings("serial")
abstract public class DmcTypeMyType extends DmcAttribute<MyType> implements Serializable {
	
	// The obligatory zero arg constructor.
	public DmcTypeMyType(){
	}
	
        // This constructor is mandatory and passes required information to the DmcAttribute
	public DmcTypeMyType(DmcAttributeInfo ai){
		super(ai);
	}
}}}

Nothing complicated here, the class is abstract, it extends `DmcAttribute` and has a couple of constructors; that's it.

The next portion is a little more interesting, but still straight forward:

{{{		
    @Override
    public MyType typeCheck(Object value) throws DmcValueException {
        MyType rc = null;
		
        if (value instanceof MyType)
            rc = (MyType)value;
        else if (value instanceof String)
            rc = new MyType((String)value);
        else
            throw(new DmcValueException("Useful error message");
        return(rc);
    }
}}}

The `typeCheck` method provides a basic mechanism for verifying that a value passed in for an attribute of the specified type conforms to that type. If it does, it passes back a value of the required type. If not, a `DmcValueException` should be thrown.

The next part just allows for a standard deep cloning mechanism on `DmcObject` i.e the `cloneIt()` method. This is where the standard clone constructor on your primitive type comes in handy!

{{{
    @Override
    public MyType cloneValue(MyType original) {
        return(new MyType(original));
    }
}}}

And finally, support for serialization/deserialization, which, if you followed the basic layout for a value container, is quite straight forward.

{{{
        
    /**
     * Write a MyType.
     * @param dos The output stream.
     * @param value The value to be serialized.
     * @throws Exception
     */
    public void serializeValue(DmcOutputStreamIF dos, MyTypevalue) throws Exception {
        value.serializeIt(dos);
    }

    /**
     * Read a MyType.
     * @param dis the input stream.
     * @return A value read from the input stream.
     * @throws Exception
     */
    public MyType deserializeValue(DmcInputStreamIF dis) throws Exception {
    	MyType rc = new MyType();
        rc.deserializeIt(dis);
        return(rc);
    }

}}}


</td>
</tr>

<tr>
<td valign="top">
*3.*
</td>
<td valign="top">
So, all of the hard work is done.

Now you just need to define the type in your [DMSOverview Schema], as follows:

{{{
TypeDefinition
name 		MyType
typeClassName	com.example.shared.types.DmcTypeMyType
primitiveType   org.example.shared.types.MyType
description	The MyType lets me store what I want.
}}}
</td>
</tr>

</table>