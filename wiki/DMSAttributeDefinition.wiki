#summary Description of the Dark Matter Schema AttributeDefinition.

<wiki:toc />

= Attribute Definitions =

The `AttributeDefinition` allows you define named attributes that will be included in [DMSClassDefinition Class Definitions], the next step in your schema specification. By defining the attributes separately, you can reuse attributes in many objects.

{{{
AttributeDefinition
name             <unique name>
type             <defined type reference>
dmdID            <unique identifier>
valuetype        <cardinality>
nullReturnValue  <a value appropriate to the type>
}}}

<table width="820">
<tr>
<td width="135" valign="top">
*`name`* 
</td>
<td>
indicates the unique name of this attribute across all schemas that you eventually wind up using in your application.  
</td>
</tr>

<tr>
<td valign="top">
*`type`* 
</td>
<td>
this is a reference to one of the [DMSTypeDefinition#Built_in_Types built in types] or one that you've defined as part of your schema.
</td>
</tr>

<tr>
<td valign="top">
*`dmdID`* 
</td>
<td>
the unique identifier for this attribute within your schema. The identifier base (`schemaBaseID`) and range (`schemaIDRange`) for your schema are defined as part of the [[DMSSchemaDefinition#An_Example_Schema_Definition] `SchemaDefinition`.
</td>
</tr>

<tr>
<td valign="top">
*`valueType`* 
</td>
<td>
indicates the cardinality and organization of the attribute values; this is based on the `ValueTypeEnum`. The allowable values are:
<table>

<tr>
<td width="100">
`SINGLE`
</td>
<td>
a single value
</td>
</tr>

<tr>
<td>
`MULTI`
</td>
<td>
an `ArrayList` of values
</td>
</tr>

<tr>
<td valign="top">
`HASHMAPPED`
</td>
<td>
a `HashMap` of values. The primitive value must implement the `DmcMappedAttributeIF` interface and the `TypeDefinition` must indicate the `keyClass`. 
</td>
</tr>

<tr>
<td>
`TREEMAPPED`
</td>
<td>
a `TreeMap` of values, in case you want the values in sorted order.
</td>
</tr>

<tr>
<td>
`HASHSET`
</td>
<td>
a `HashSet` of values.
</td>
</tr>

<tr>
<td>
`TREESET`
</td>
<td>
a `TreeSet` of values, in case you want the values in sorted order.
</td>
</tr>
</table>

</td>
</tr>

<tr>
<td valign="top">
*`nullReturnValue`* 
</td>
<td>
in cases where you'd like to always have a value for an attribute, you can specify a null return value. This is only applicable to single-valued attributes.

Now some might say, "Why don't you just have an attribute initialization mechanism?". Well, I guess we could, but why bother assigning storage and transporting a value around when we don't need to? This way, the `getter()` method on the [[DMOOverview DMO] just checks to see if the attribute exists and, if not, returns the `nullReturnValue`.
</td>
</tr>
<tr>
<td valign="top">
*`description`* 
</td>
<td>
a description of the attribute, possibly including its semantics.
</td>
</tr>

</table>


== Single-valued Attributes ==

Below is an example of a single-valued attribute definition:

{{{
AttributeDefinition
name        stockSymbol
type        String
dmdID       1
description The registered stock symbol for stock in a company.
}}}

This is about the simplest `AttributeDefinition` you can have. It indicates a `name` for the attribute, a `type` (from one of the [DMSTypeDefinition#Built_in_Types built in types] or from your own type definitions, a unique identifier (within this schema) and a `description` (which is optional).

You'll notice that we don't specify `valueType SINGLE`. That's because the `nullReturnValue` for the `ValueTypeEnum` type is `SINGLE`.

When the [DMOOverview DMO] is generated for this attribute, the following getters/setters will be generated:

 * `setStockSymbol(Object value) throws DmcValueException`
 * `setStockSymbol(String value)`
 * `String getStockSymbol()`

== MULTI Attributes ==

There are several different types of multi-valued attributes; this is indicated by the `valueType` attribute of the `AttributeDefinition`. Here's a definition for a multi-valued Integer attribute:

{{{
AttributeDefinition
name        intArray
type        Integer
valueType   MULTI
description An array if integers that blah, blah ,blah
}}}

All defined types can exist as single-valued or multi-valued attributes. 

When the [DMOOverview DMO] is generated for this attribute, the following methods will be generated:

 * `addIntArray(Object value) throws DmcValueException`
 * `addIntArray(Integer value)`
 * `Iterator<Integer> getIntArray()`

== `HASHMAPPED` & `TREEMAPPED` Attributes ==

An example of a `TREEMAPPED` attribute:

{{{
AttributeDefinition
name        intToString
type        IntegerToString
valueType   TREEMAPPED
description Maps a set of integer values to their String equivalents.
}}}

When the [DMOOverview DMO] is generated for this attribute, the following methods will be generated:

 * `addIntToString(Object value) throws DmcValueException`
 * `addIntToString(Integer value)`
 * `Iterator<Integer> getIntToString()`

Now, since this is a mapped type, you might be wondering, "Where's the key for value?". Well, it's built in to the value itself and that's why values that are stored in mapped attributes have to implement the `DmcMappedAttributeIF`, which implies that the value has a getKey() method.

== `HASHSET` & `TREESET` Attributes == 

An example of a `HASHSET` attribute:

{{{
AttributeDefinition
name        myAliases
type        String
valueType   HASHSET
description A set of pseudonyms by which you may refer to me.
}}}

When the [DMOOverview DMO] is generated for this attribute, the following methods will be generated:

 * `addMyAliases(Object value) throws DmcValueException`
 * `addMyAliases(String value)`
 * `Iterator<Integer> getMyAliases()`

And obviously, the attribute follows SET semantics; no duplicate values allowed.

== A Note About Single-valued Boolean Attributes ==

The getters generated on DMOs for attributes usually take the form `get[attrname]()`, as indicated previously. For single-valued Boolean attributes, however, things are slightly different:

{{{
AttributeDefinition
name        fabulous
type        Boolean
description A flag to indicate if something is fabulous.
}}}

The getters/setters will appear as:

 * `setFabulous(Object value) throws DmcValueException`
 * `setFabulous(Boolean value)`
 * `isFabulous()`

So the "getter" is `isFabulous()`. Having things this way just makes code a bit more readable.