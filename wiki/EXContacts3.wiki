#summary A discussion of Events and Views in Model View Whatever.

<wiki:toc />

= Events & Views: Introduction =

There's an awful lot of syntactic cruft surrounding Model View Controller, Model View Presenter, Model View Activity Place [http://code.google.com/webtoolkit/doc/latest/DevGuideMvpActivitiesAndPlaces.html#ClientFactory ClientFactory] [http://code.google.com/webtoolkit/doc/latest/DevGuideRequestFactory.html RequestFactory] etc. etc. etc.

That's why I've called this approach Model View Whatever.

The two things that are common across all of these approaches are the Model (which we've defined using Dark Matter Schema) and Views (which we'll discuss shortly) and frankly, I don't care what you call the rest of it; use "Whatever" nomenclature makes sense in your particular development activity.

The goal of making your software more easily testable is a noble goal; this is primarily achieved in the various GWT approaches to web application/site structure by defining interfaces for everything. The approach obviously has its merits, but it takes a while to sift through the various examples and develop a clear idea of all the bits and pieces you need to define to make a real, functional web application/site using these approaches.

The focus of the next few sections to is provide a solid conceptual foundation of the role that Events and Views play in the overall architecture of an application and how they relate to the Model.

== Events: Local and Broadcast ==

Events are the driving force behind any significantly complex system. The basic role of events is described  in the [http://code.google.com/webtoolkit/articles/mvp-architecture.html#events Events and the Event Bus] section of the [http://code.google.com/webtoolkit/articles/mvp-architecture.html MVP overview]

One import note regarding events is nicely described:
<table width="600">
<tr>
<td width="20" valign="top">
</td>
<td valign="top">
_It's important to keep in mind that not all events should be placed on the Event Bus. Blindly dumping all of the possible events within your app on the Event Bus can lead to chatty applications that get bogged down in event handling. Not to mention, you'll find yourself writing a fair amount of boilerplate code to define, source, sink, and act upon these events._

</td>
</tr>
</table>
What this statement implies is that events have an implied "scope" i.e. some events are only meant for immediate handling by some entity (controller, presenter, activity, whatever) that is directly related to a View, while other events are more global in scope i.e. meant to be broadcast on the Event Bus.

MVW makes a clear distinction between these types of events and refers to them as *Local Events* and *Broadcast Events*. It is always clear what the scope of an event is when you're defining different aspects of the MVW configuration.
<table border=0 width="100%">
  <tr>
    <td><img width="500" src="http://www.dark-matter-data.org/images/mvwEvents.png" />

</td>
  </tr>
</table>

Now, although we refer to Local Events, it should be understood that Local Events are not full fledged `GwtEvents`, they are, in fact, merely method signatures in an interface. Only Broadcast Events are generated as `GwtEvents`.

This should become more clear as we define views required for our Contacts example.

== Views ==

A View is some representation of one or more instances of data objects as defined by a model.

Users may interact with the View and cause various events to take place. Some of these events are data related e.g. modify this data, create some new data, delete this data, I've selected this data etc.

Other events generated by Views influence the flow of the overall user interaction e.g. close this View, open a different View, navigate to another place etc.

I don't think there's anything too controversial in those three statements, or, maybe I'm wrong, maybe I'm completely off base. Regardless, I'm going to proceed on the assumption that all is well.

However, despite my best efforts, I cannot agree with the following statement about [http://code.google.com/webtoolkit/articles/mvp-architecture.html#view views not having any notion of the model]:

<table width="600">
<tr>
<td width="20" valign="top">
</td>
<td valign="top">
_A view contains all of the UI components that make up our application. This includes any tables, labels, buttons, textboxes, etc... Views are responsible for the layout of the UI components and have no notion of the model. That is to say a view doesn't know that it is displaying a Contact, it simply knows that it has, for example, 3 labels, 3 textboxes, and 2 buttons that are organized in a vertical fashion._

</td>
</tr>
</table>

I'm all for defining clear interfaces between Views and Whatever, but a View IS designed to display a particular Model. Views are not generally reusable to display any bunch of random values you happen to have lying around. They are expressly created to present, in whatever manner is deemed suitable, a coherent set of data and/or allow a user to manipulate that data and let the system know about it.

Try as you might to lobotomize Views and Models, it doesn't make any sense.

It does make sense to have clear interfaces across the Model, View, Whatever boundaries.

=== Populating the View: The Data Interface ===

A View displays data.

Exactly what data operations are supported by a View will be referred to as the Data Interface.

The various types of data operations fall in to the following categories:

<table width="600">

<tr>
<td width="140" valign="top">
*population*
</td>
<td valign="top">
allows an entity to populate the View with the data object/objects it was designed to display. The interface here is at the object level, not at the field or attribute level. 
</td>
</tr>

<tr>
<td valign="top">
*get selected*
</td>
<td valign="top">
allows an entity to determine which object or collection of objects has been selected within the View. Note: this information may also be made available via a Broadcast Event - see the Event Interface description.
</td>
</tr>

<tr>
<td valign="top">
*set selected*
</td>
<td valign="top">
allows an entity to indicate that the specified object or object collection is selected.
</td>
</tr>

<tr>
<td valign="top">
*update*
</td>
<td valign="top">
allows an entity to notify the View that one or more of the objects it is displaying has changed state.
</td>
</tr>

</table>

So far, so good, but what about modifying the data?

=== Listening to the View: The Event Interface ===

All data modification and potentially selection notifications and other user interaction takes place through the Event Interface which allows for:

<table width="600">

<tr>
<td width="140" valign="top">
*object creation*
</td>
<td valign="top">
the user has requested the creation of a new object. The object is passed along in the "local event" i.e. the member function called on the entity that implements the event interface.
</td>
</tr>

<tr>
<td valign="top">
*object deletion*
</td>
<td valign="top">
the user has requested that an object be deleted.
</td>
</tr>

<tr>
<td valign="top">
*object modification*
</td>
<td valign="top">
the user has requested that a set of [http://code.google.com/p/dark-matter-data/wiki/EXContacts2#Modification_Recording modifications] be made to an object.
</td>
</tr>

<tr>
<td valign="top">
*object selection*
</td>
<td valign="top">
the user has selected one or more objects displayed in the view. This type of event may be defined as Local or as Local and Broadcast, depending on the needs of the application. A case where broadcasting comes in handy is when you have web application (perhaps using a desktop paradigm) and you want to control context sensitive menus based on the current selection context.
</td>
</tr>

<tr>
<td valign="top">
*other*
</td>
<td valign="top">
simply refers to any other type of user interaction that entity associated with the view might need to respond to.
</td>
</tr>

</table>

== Defining a View ==

{{{
View
viewName 
}}}


== Defining `BroadcastEvents` ==