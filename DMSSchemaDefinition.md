

<font color='#6a6a6a'>
<h1>Schema Definitions</h1>
</font>

This page provides you with a basic overview of the Dark Matter Schema (DMS) definition mechanisms.

## A Note About Project Source Structure ##

A great deal of the infrastructure required by applications that use Dark Matter is automatically generated from the schema that you define. Code is generated in relation to where you place certain configuration files, for instance the DMS files that end with `.dms` extensions.

You are free to place these files wherever you want but certain source structures fit with the spirit of [GWT](http://code.google.com/webtoolkit/overview.html) which generally structures the source hierarchy as follows:

```
src
    com
        example
            client
                (client specific code)
            server
                (server specific code)
            shared
                (code shared by client and server)
```

The code generated from DMS falls into the shared category and your `.dms` file should be placed accordingly:

```
src
    com
        example
            client
            server
            shared
                dmdconfig
                    (a standard name for a folder where DMD config files live)
                    v0dot1
                        (an optional versioning folder - see the Versioning section)
                       myschema.dms

```

All code generated by the various generators used by Dark Matter will be created beneath a **`generated`** folder; this makes it quite clear which subfolders should be specified in your `.gwt.xml` source path declarations (if you don't follow the convention of placing shared code in a single folder).

After running the [DMO Generator](DMOGenerator.md) on your schema, the source structure will appear as follows:

```
src
    com
        example
            client
            server
            shared
                dmdconfig
                    v0dot1
                        myschema.dms
                generated
                    dmo
                    enums
                    types
                    ...
```

## Splitting Your Schemas Based on Feature ##

The subset of objects associated with a particular feature can also be contained in separate schemas; this makes the creation of well defined functional modules very straight forward.

Here's another way to structure your files:

```
src
    com
        example
            client
            server
            shared
                feature1
                    dmdconfig
                        v0dot1
                            feature1.dms
                    generated
                       dmo
                       enums
                       types

                feature2
                    dmdconfig
                        v0dot1
                            feature2.dms
                    generated
                       dmo
                       enums
                       types

                feature-n
                    dmdconfig
                        v0dot1
                            feature-n.dms
                    generated
                       dmo
                       enums
                       types
```

Now, each feature and its associated schema are neatly separated. This also has implications on the structure of your reusable GWT Modules which is covered on the [Resuable Modules](MVWModules.md) page.


## Versioning of DMD Configurations ##

Although not implemented yet, mechanisms will be available to provide you with succinct descriptions of what has changed between versions of various DMD configuration files, including schema definitions.

By creating subfolders beneath the dmdconfig folder (which can be named arbitrarily) with a naming convention of `v`#`dot`#, you can maintain separate versions of configurations that will make it easy to provide difference reports that go far beyond using `diff`.

At a schema level, these delta reports will indicate clearly things like
  * classes added/deleted
  * attributes added/deleted to a class
  * changes in derivation hierarchy
  * changes in attribute type
  * etc.

One benefit of this is to make the creation of release notes about your data API very easy and clear.

Anyway, you don't have to follow this convention, but there will be benefits later. Trust me. ;-)

## An Example Schema Definition ##

A `.dms` file contains the instance of a `SchemaDefinition` [DMO](DMOOverview.md). Here's an example in file named `featureD.dms`:

```
SchemaDefinition
name            featureD
schemaPackage   com.example.shared
schemaBaseID    1000
schemaIDRange   50
dependsOn       featuresBase
dependsOn       featureA
defFiles        types.dmd
defFiles        attributes.dmd
defFiles        classes.dmd
description     The featureD schema defines objects associated with
 management of whatsits in the overall context of the whosits.
```

Let's look at the basic aspects of a `SchemaDefinition`.

<table width='820'>

<tr>
<td width='150' valign='top'>
<b><code>SchemaDefinition</code></b>
</td>
<td>
all Dark Matter configurations are specified in <a href='DMOOverview#Object_Instance_Format.md'>Object Instance Format</a> so this is the class of object we're dealing with (I'll stop harping about <a href='DMOOverview#Object_Instance_Format.md'>OIF</a> shortly, but it's fundamental, so bear with me).<br>
<br>
</td>
</tr>

<tr>
<td valign='top'>
<b><code>name</code></b>
</td>
<td>
this is the name of the schema which <b>MUST</b> match the name of the <code>.dms</code> file in which it is defined. This name must be globally unique within the set of schemas that you are going to use for an application.<br>
<br>
When you refer to a schema through a <code>dependsOn</code> attribute, this is the name you're referring to.<br>
<br>
</td>
</tr>

<tr>
<td valign='top'>
<b><code>schemaPackage</code></b>
</td>
<td>
this is the full package name leading to the location where the <code>dmdconfig</code> folder resides, in the case of the files structures we've been using in the examples, the <code>schemaPackage</code> for feature1 would be <code>com.example.shared.feature1</code>

</td>
</tr>

<tr>
<td valign='top'>
<b><code>schemaBaseID</code></b>
</td>
<td>
attributes and classes have unique integer identifiers that allow for very compact DMO serialization. The <code>schemaBaseID</code> indicates the base identifier for all definitions in your schema. Identifiers below 2000 are reserved for Dark Matter internal use, so be sure to start your numbering above 2000.<br>
<br>
</td>
</tr>


<tr>
<td valign='top'>
<b><code>schemaIDRange</code></b>
</td>
<td>
if you are building your application in a modular way, you will likely have many schemas that describe the objects associated with different feature sets. The <code>schemaIDRange</code> just puts an upper bound on the identifiers associated with this schema.<br>
<br>
</td>
</tr>


<tr>
<td valign='top'>
<b><code>dependsOn</code></b>
</td>
<td>
this is an <a href='DMONaming.md'>object reference</a> to an existing schema. You may refer to other schemas to allow for class derivation or the reuse of attributes, types etc. You'll notice that it's a multi-valued attribute (just repeat the name of the attribute and provide another value).<br>
</td>
</tr>

<tr>
<td valign='top'>
<b><code>defFiles</code></b>
</td>
<td>
these are the names of other definition files that will be read when this schema configuration is read. They can be named anything, but the convention is to name them for the kinds of definitions that they contain e.g. <a href='DMSAttributeDefinition.md'>attributes</a>, <a href='DMSTypeDefinition.md'>types</a>, <a href='DMCClassDefinition.md'>classes</a> etc.<br>
<br>
</td>
</tr>

<tr>
<td valign='top'>
<b><code>description</code></b>
</td>
<td>
you are encouraged to provide descriptions of your definitions so that useful documentation can be generated.<br>
</td>
</tr>

</table>

## A Note About Attribute and Class Identifiers ##

All attributes and classes defined in Dark Matter Schema have a unique identifier within the context of the schema.

Why?

There are a few reasons:

  1. by using unique IDs for attributes, access to attributes in the [Dark Matter Object](DMOOverview.md) is very efficient
  1. when using GWT RPC, the names of attributes don't have to be serialized on the wire
  1. likewise, when using Dark Matter's own, serialization mechanisms, attribute and class names don't have to be serialized
  1. so, primarily, it's an efficiency thing ;-)