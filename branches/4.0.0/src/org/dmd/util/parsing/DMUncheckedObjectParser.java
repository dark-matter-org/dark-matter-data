//	---------------------------------------------------------------------------
//	dark-matter-data
//	Copyright (c) 2014 dark-matter-data committers
//	---------------------------------------------------------------------------
//	This program is free software; you can redistribute it and/or modify it
//	under the terms of the GNU Lesser General Public License as published by the
//	Free Software Foundation; either version 3 of the License, or (at your
//	option) any later version.
//	This program is distributed in the hope that it will be useful, but WITHOUT
//	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//	FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for
//	more details.
//	You should have received a copy of the GNU Lesser General Public License along
//	with this program; if not, see <http://www.gnu.org/licenses/lgpl.html>.
//	---------------------------------------------------------------------------
package org.dmd.util.parsing;

import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.StringTokenizer;

import org.dmd.core.feedback.DMFeedback;
import org.dmd.core.feedback.DMFeedbackSet;
import org.dmd.core.feedback.DMParsingFeedback;
import org.dmd.core.util.DMUncheckedObject;

/**
 * This class parses files that conform to Object Instance Format (OIF).
 * <P>
 * Object Instance Format is a text-based format that allows for the capture
 * of just about any type of data. The kinds of objects that can be represented
 * depend on schemas that are defined as part of a dark-matter schema (DMS).
 * <P>
 * At this level of parsing, no real error checking is performed - that will be
 * taken care of by the object handler that understands the specifics of the
 * schema that should be followed by the objects in the file.
 * @see #parseFile
 */

public class DMUncheckedObjectParser {

    // Handler to which newly parsed objects will be passed.
    DMUncheckedObjectHandlerIF    handler;

    // Indicates the number of errors that the caller is willing to encounter before we halt parsing.
    int     allowedErrorsV;
    
    // Place to hang on to feedback (which may include errors/warnings generated by our handler
    DMFeedbackSet	feedback;
    
    // Indicates the attributes that should have their newlines preserved
    HashMap<String, String> 	preserveNL;

    /**
      * Creates a new Object Instance Format parser. As new BasicObjects are created,
      * they will be passed to the object handler for processing.
      */
    public DMUncheckedObjectParser(DMUncheckedObjectHandlerIF objHandler) {
        handler         = objHandler;
        allowedErrorsV  = 0;
        feedback		= null;
        preserveNL		= new HashMap<String, String>();
    }
    
    public void addPreserveNewlinesAttribute(String an){
    	preserveNL.put(an, an);
    }

    /**
     * Allows you to set the number of errors that you're willing to ignore during
     * the parsing. The default is to quit parsing whenever an error is encountered.
     * If you don't care how many errors you find, set the allowedErrors to -1.
     * <P>
     * The parsing will always stop if we encounter a FATAL error (as reflected
     * in the ResultSet).
     */
    public void allowedErrors(int i){
        allowedErrorsV = i;
    }

    /**
     * Parses the specified file and sends the objects to the object handler specified in
     * the constructor.
     * @param fileName The file to be parsed.
     * @throws DMFeedbackSet 
     */
    public void parseFile(String fileName) throws DMFeedbackSet {
    	parseFile(fileName,false);
    }

    /**
     * Parses the specified file and sends the objects to the object handler specified in
     * the constructor.
     * @param fileName The file to be parsed.
     * @param isResource A flag to indicate if the file name refers to a resource e.g. in a JAR. If so,
     * we have to approach the opening of the file differently.
     * @throws DMFeedbackSet 
     */
    public void parseFile(String fileName, boolean isResource) throws DMFeedbackSet {
        boolean         	inObject    = false;
        String          	attrName    = null;
        DMUncheckedObject 	uco    		= null;
        StringBuffer    	attrVal     = new StringBuffer();
        String          	val         = null;
        // Note: we replace the friggin' windows backslashes with forward slashes
        String          	fn          = fileName.replace('\\', '/');
        int					lastLine	= 0;
        LineNumberReader	in			= null;

        // Reset out global exception instance
        feedback = null;

        try {
            // BufferedReader in = new BufferedReader(new FileReader(fileName));
        	
        	if (isResource){
    			InputStreamReader isr = new InputStreamReader(getClass().getResourceAsStream(fn));
    			in = new LineNumberReader(isr);        		
        	}
        	else
        		in = new LineNumberReader(new FileReader(fileName));

        	String str;
            while ((str = in.readLine()) != null) {
                if (str.startsWith("*") || str.startsWith("//")){
                    // It's a comment, skip it
                }
                else{
                    StringTokenizer t = new StringTokenizer(str);

                    if (t.countTokens() != 0){
                        if (inObject == false){
                            ArrayList<String> al = new ArrayList<String>();
                            // We're starting a new object - these tokens should be the classes
                            while(t.hasMoreTokens()){
                                al.add(t.nextToken().trim());
                            }

                            uco = new DMUncheckedObject(al,fileName,in.getLineNumber());
                            inObject = true;
                            attrName = null;
                        }
                        else{
                            // We have tokens
                            if (Character.isWhitespace(str.charAt(0))){
                                // Line continuation
                            	if (preserveNL.get(attrName) != null)
                                    attrVal.append("\n" + str);
                            	else
                            		attrVal.append(str);
                            }
                            else{
                                // A new attribute line
                                if (attrName != null){
                                    // Add the current attribute to the object
                                	val = attrVal.toString().trim();
                                	
                                	if (preserveNL.get(attrName) != null)
                                		val = val.replaceAll("\n", "\\\\n");
                                	
                                    uco.addValue(attrName,new String(val));
                                }

                                // Get the new attribute name
                                attrName = t.nextToken().trim();

                                // Wipe the value buffer
                                attrVal.delete(0,attrVal.length());

                                // Reset it with the contents of the current line
                                attrVal.append(str);

                                // Trim the attribute name and leading spaces
                                attrVal.delete(0,attrName.length());
                                if (attrVal.length() == 0){
                            		// We have a missing token value
                                	DMParsingFeedback ex = new DMParsingFeedback("No value for attribute: " + attrName, fileName, in.getLineNumber());
                                	DMFeedbackSet exset = new DMFeedbackSet(ex);
                            		throw(exset);
                                }
                                while(attrVal.charAt(0) == ' '){
                                    attrVal.delete(0,1);
                                }
                            }
                        }
                    }
                    else{
                        if (uco != null){
                            // We have a blank line which means we've reached the end of an object - pass off
                            // the current object for processing
                            inObject = false;

                            // Tack on the last attribute
                            if (attrName != null){
                                val = attrVal.toString().trim();
                                
                            	if (preserveNL.get(attrName) != null)
                            		val = val.replaceAll("\n", "\\\\n");
                            	
                                uco.addValue(attrName,new String(val));
                            }

                            try{
                            	handler.handleObject(uco,fn, in.getLineNumber());
                            }
                            catch(DMFeedbackSet ex){
                            	// If this is the first exception, just hang on to it - we may
                            	// wind up adding to it later. Otherwise, just append the results
                            	// to our existing exception.
                            	if (feedback == null)
                            		feedback = ex;
                            	else
                            		feedback.add(ex);
                            	
                                if (allowedErrorsV == -1){
                                    // Couldn't care less about errors! Just go merrily on our way.
                                }
                                else if ((allowedErrorsV == 0) && (feedback.error())){
                                    // Couldn't allow errors - let's bail
                                    uco = null;
                                    break;
                                }
                                else if (feedback.errors() >= allowedErrorsV){
                                    // We've reached the limits of our patience
                                    uco = null;
                                    break;
                                }

                            }

                            // Reset our object and go on for the next one
                            uco = null;
                        }
                    }
                }

                lastLine = in.getLineNumber();
            }
            in.close();
        }
        catch (IOException e) {
        	if (feedback == null)
        		feedback = new DMFeedbackSet();
        	
        	feedback.add(new DMFeedback(e.toString(), fileName, in.getLineNumber()));
        	uco = null;
        }
        catch(Exception e){
        	if (feedback == null)
        		feedback = new DMFeedbackSet();
        	
        	feedback.add(new DMFeedback(e.toString(), fileName, in.getLineNumber())); 
        	uco = null;
        }

        if (uco != null){
            // Finish off for the final attribute and object
            if (attrName != null){
                // Add the current attribute to the object
                // System.out.println("Adding *" + attrVal + "*");
                val = new String(attrVal);
                
            	if (preserveNL.get(attrName) != null)
            		val = val.replaceAll("\n", "\\\\n");
            	
                uco.addValue(attrName,val.trim());
            }

            try{
            	handler.handleObject(uco,fn,lastLine);
            }
            catch(DMFeedbackSet ex){
            	// This is here to prevent problems when this same instance of the parser is used
            	// in multiple parsing exercises and we don't want to keep throwing/catching the 
            	// same exception.
            	if (ex == feedback)
            		throw(feedback);
            	
            	if (feedback == null)
            		feedback = ex;
            	else
            		feedback.add(ex);
            }
        }
        
        if (feedback != null)
        	throw(feedback);

    }

}
 

