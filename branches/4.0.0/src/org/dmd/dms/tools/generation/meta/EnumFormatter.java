package org.dmd.dms.tools.generation.meta;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Iterator;
import java.util.TreeMap;

import org.dmd.core.feedback.DMFeedbackSet;
import org.dmd.core.util.DMUncheckedObject;
import org.dmd.core.util.NamedStringArray;
import org.dmd.dms.shared.types.EnumValue;
import org.dmd.util.artifact.FileUpdateManager;
import org.dmd.util.artifact.java.CommentFormatter;
import org.dmd.util.runtime.DebugInfo;

public class EnumFormatter {

	/**
	 * This method dumps a Java enum for the specified type definition.
	 * @param od The output directory.
	 * @param enumObj The enumeration definition object.
	 * @throws IOException If we have problems dumping to the file.
	 * @throws DMFeedbackSet 
	 */
	static public void dumpEnumClass(String od, DMUncheckedObject enumObj, String LGPL) throws IOException, DMFeedbackSet {
		NamedStringArray al = null;
		BufferedWriter enumClassDef = null;
		TreeMap<Integer, EnumValue> byId = new TreeMap<Integer, EnumValue>();
		TreeMap<String, EnumValue> byName = new TreeMap<String, EnumValue>();

//		String cp = "org.dmd.dms";
		String cn = enumObj.getSV("name");

		// Get the enumValues attribute
		if ((al = enumObj.get("enumValue")) == null) {
			System.out.println("Couldn't get enumValues from:\n" + enumObj);
			return;
		}

		for (String enumValName : al) {
			EnumValue ev = new EnumValue(enumValName);

			if (byId.get(ev.getId()) != null) {
				throw(new IllegalStateException("Duplicate enum id: " + ev.getId() + " at line: " + enumObj.getLineNumber()));
			}
			byId.put(ev.getId(), ev);

			if (byName.get(ev.getName()) != null) {
				throw(new IllegalStateException("Duplicate enum name: " + ev.getName() + " at line: " + enumObj.getLineNumber()));
			}
			byName.put(ev.getName(), ev);
		}

		enumClassDef = FileUpdateManager.instance().getWriter(od, cn + ".java");

		enumClassDef.write(LGPL);
		enumClassDef.write("package org.dmd.dms.shared.generated.enums;\n\n");

		enumClassDef.write("import java.util.*;\n\n");

		enumClassDef.write("/**\n * The " + cn + " enumeration.\n");
		enumClassDef
				.write(" * This code was auto-generated by the createmeta utility and shouldn't be alterred\n");
		enumClassDef.write(" * manually.\n");
		enumClassDef.write(" * Generated from: " + DebugInfo.getWhereWeAreNow()
				+ "\n");
		enumClassDef.write(" */\n");
		enumClassDef.write("public enum " + cn + "\n{\n");

		Iterator<EnumValue> enumit = byId.values().iterator();
		while (enumit.hasNext()) {
			EnumValue ev = enumit.next();

			enumClassDef.write("    /**\n");
			enumClassDef.write(CommentFormatter.format(ev.getDescription(), "     * "));
			enumClassDef.write("     */\n");

			enumClassDef.write("    " + ev.getName() + "(" + ev.getId() + ")");
			if (enumit.hasNext())
				enumClassDef.write(",\n\n");
			else
				enumClassDef.write(";\n\n");
		}

		enumClassDef
				.write("    // Maps our integer value to the enumeration value\n");
		enumClassDef.write("    private static final Map<Integer," + cn
				+ "> lookup = new HashMap<Integer," + cn + ">();\n\n");

		enumClassDef.write("    static {\n");
		enumClassDef.write("        for(" + cn + " s : EnumSet.allOf(" + cn
				+ ".class))\n");
		enumClassDef.write("            lookup.put(s.intValue(), s);\n");
		enumClassDef.write("    }\n\n");

		enumClassDef
				.write("    // Maps our enumeration (string) value to the enumeration value\n");
		enumClassDef.write("    private static final Map<String," + cn
				+ "> lookupString = new HashMap<String, " + cn + ">();\n\n");

		enumClassDef.write("    static {\n");
		enumClassDef.write("        for(" + cn + " s : EnumSet.allOf(" + cn
				+ ".class))\n");
		enumClassDef.write("            lookupString.put(s.name(), s);\n");
		enumClassDef.write("    }\n\n");

		enumClassDef
				.write("    // Our current value as an int - normally, this isn't available in an enum\n");
		enumClassDef.write("    private int ival;\n\n");

		enumClassDef.write("    /**\n");
		enumClassDef
				.write("     * This private constructor allows us to access our int value when required.\n");
		enumClassDef.write("     */\n");
		enumClassDef.write("    private " + cn + "(int i){\n");
		enumClassDef.write("        ival = i;\n");
		enumClassDef.write("    }\n\n");

		enumClassDef.write("    /**\n");
		enumClassDef
				.write("     * Returns the value of this enum value as an int.\n");
		enumClassDef.write("     */\n");
		enumClassDef.write("    public int intValue(){\n");
		enumClassDef.write("        return(ival);\n");
		enumClassDef.write("    }\n\n");

		enumClassDef.write("    /**\n");
		enumClassDef
				.write("     * Returns the enum value of the specified int or null if it's not valid.\n");
		enumClassDef.write("     */\n");
		enumClassDef.write("    public static " + cn + " get(int code) {\n");
		enumClassDef.write("        return(lookup.get(code));\n");
		enumClassDef.write("    }\n\n");

		enumClassDef.write("    /**\n");
		enumClassDef
				.write("     * Returns a value for this enum or throws an exception if the String value isn't\n");
		enumClassDef.write("     * a valid member of this enum.\n");
		enumClassDef.write("     */\n");
		enumClassDef.write("    public static " + cn + " get(String str) {\n");
		enumClassDef.write("        return(lookupString.get(str));\n");
		enumClassDef.write("    }\n\n");

		enumClassDef.write("}");
		enumClassDef.close();
	}


}
