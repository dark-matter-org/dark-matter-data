//	---------------------------------------------------------------------------
//	dark-matter-data
//	Copyright (c) 2010 dark-matter-data committers
//	---------------------------------------------------------------------------
//	This program is free software; you can redistribute it and/or modify it
//	under the terms of the GNU Lesser General Public License as published by the
//	Free Software Foundation; either version 3 of the License, or (at your
//	option) any later version.
//	This program is distributed in the hope that it will be useful, but WITHOUT
//	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//	FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for
//	more details.
//	You should have received a copy of the GNU Lesser General Public License along
//	with this program; if not, see <http://www.gnu.org/licenses/lgpl.html>.
//	---------------------------------------------------------------------------
package org.dmd.dms.tools.generation.dmogen;

import java.io.BufferedWriter;
import java.io.IOException;
import java.util.Iterator;

import org.dmd.dms.server.extended.DmsModule;
import org.dmd.dms.server.extended.EnumDefinition;
import org.dmd.dms.shared.types.EnumValue;
import org.dmd.util.artifact.FileUpdateManager;
import org.dmd.util.artifact.java.ImportManager;
import org.dmd.util.formatting.CodeFormatter;
import org.dmd.util.runtime.DebugInfo;

/**
 * The DmoTypeFormatter will generate the various types associated with schema defined
 * enumerations and the object reference types.
 */
public class DmoEnumFormatter {
	
	static String fileHeader;
	
	/**
	 * This method will generate the enum classes for all EnumDefinitions in the specified schema module.
	 * @param module    The schema.
	 * @param outdir 	Where to dump the class.
	 * @param fh 		The file header
	 * @throws IOException
	 */
	static public void dumpEnums(DmsModule module, String outdir, String fh) throws IOException{
		fileHeader = fh;
		Iterator<EnumDefinition> enums = module.getAllEnumDefinition();
		if (enums != null){
			while(enums.hasNext())
				dumpEnum(enums.next(),outdir);
		}
	}
	
	static private void dumpEnum(EnumDefinition ed, String outdir) throws IOException{
		String cn = ed.getName().getNameString();
      	String schemaPackage = ed.getDefinedInDmsModule().getSchemaPackage();
		BufferedWriter 	out = FileUpdateManager.instance().getWriter(outdir, cn + ".java");
      
        out.write(fileHeader);

      	out.write("package " + schemaPackage + ".generated.enums;\n\n");

      	ImportManager imports = new ImportManager();
      	imports.addImport("org.dmd.core.interfaces.DmcEnumIF", "Standard interface for enums");
      	imports.addImport("java.util.*", "To supporting mapping of enum values");
      	
        out.write(imports.getFormattedImports() + "\n\n");
        
        out.write("/**\n");
        CodeFormatter.dumpCodeComment(ed.getDescriptionWithNewlines(),out," * ");
        out.write(" * <P>\n");
        out.write(" * Generated from the " + ed.getDefinedInDmsModule().getName() + " schema at version " + ed.getDefinedInDmsModule().getVersion() + "\n");
        out.write(" * <P>\n");
        out.write(" * This code was auto-generated by the dmogenerator utility and shouldn't be altered manually!\n");
        out.write(" * Generated from: " + DebugInfo.getWhereWeAreNow() + "\n");
        out.write(" */\n");
        out.write("public enum " + cn + " implements DmcEnumIF\n{\n");

        Iterator<EnumValue> enumit = ed.getEnumValueIterable();
        while(enumit.hasNext()){
        	EnumValue ev = enumit.next();
        	
            out.write("    " + ev.getName() + "(" + ev.getId() + ",\"" + ev.getDescription() + "\")");
            if (enumit.hasNext())
            	out.write(",\n\n");
            else
            	out.write(";\n\n");
        }
        
        out.write("    // Maps our integer value to the enumeration value\n");
        out.write("    private static final Map<Integer," + cn + "> lookup = new HashMap<Integer," + cn + ">();\n\n");

        out.write("    static {\n");
      	out.write("        for(" + cn + " s : EnumSet.allOf(" + cn + ".class))\n");
      	out.write("            lookup.put(s.intValue(), s);\n");
     	out.write("    }\n\n");
        
        out.write("    // Maps our enumeration (string) value to the enumeration value\n");
        out.write("    private static final Map<String," + cn + "> lookupString = new HashMap<String, " + cn + ">();\n\n");

        out.write("    static {\n");
      	out.write("        for(" + cn + " s : EnumSet.allOf(" + cn + ".class))\n");
      	out.write("            lookupString.put(s.name(), s);\n");
     	out.write("    }\n\n");
        
        out.write("    // Our current value as an int - normally, this isn't available in an enum\n");
        out.write("    private int ival;\n\n");
        
        out.write("    // Our current display value as a String\n");
        out.write("    private String dval;\n\n");
        
        out.write("    /**\n");
        out.write("     * This private constructor allows us to access our int value when required.\n");
        out.write("     */\n");
        out.write("    private " + cn + "(int i, String d){\n");
        out.write("        ival = i;\n");
        out.write("        dval = d;\n");
        out.write("    }\n\n");
        
        out.write("    /**\n");
        out.write("     * Returns the value of this enum value as an int.\n");
        out.write("     */\n");
        out.write("    public int intValue(){\n");
        out.write("        return(ival);\n");
        out.write("    }\n\n");
        
        out.write("    /**\n");
        out.write("     * Returns the display value of this enum value as a String.\n");
        out.write("     */\n");
        out.write("    public String displayValue(){\n");
        out.write("        return(dval);\n");
        out.write("    }\n\n");
        
        out.write("    /**\n");
        out.write("     * Returns the enum value of the specified int or null if it's not valid.\n");
        out.write("     */\n");
        out.write("    public static " + cn + " get(int code) {\n");
        out.write("        return(lookup.get(code));\n"); 
        out.write("    }\n\n");
       
        out.write("    /**\n");
        out.write("     * Returns a value for this enum or throws an exception if the String value isn't\n");
        out.write("     * a valid member of this enum.\n");
        out.write("     */\n");
        out.write("    public static " + cn + " get(String str) {\n");
        out.write("        return(lookupString.get(str.toUpperCase()));\n");
      	out.write("    }\n\n");
        
        out.write("}");
      
		out.close();
	}
	
}
