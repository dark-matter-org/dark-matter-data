package org.dmd.dms.tools.generation.meta;

import java.io.BufferedWriter;
import java.io.IOException;

import org.dmd.core.feedback.DMFeedbackSet;
import org.dmd.core.util.DMUncheckedObject;
import org.dmd.util.artifact.FileUpdateManager;
import org.dmd.util.artifact.java.ImportManager;
import org.dmd.util.runtime.DebugInfo;

public class TypeFormatter {

	/**
	 * If the specified class definition is for a named object, we dump its REF definition,
	 * its related DmcType and the required helper classes for multi-valued, set, single-valued
	 * and static manipulation. For instance for the AttributeDefinition class we'll dump:
	 * AttributeDefinitionREF
	 * DmcTypeAttributeDefinitionREF
	 * DmcTypeAttributeDefinitionREFMV
	 * DmcTypeAttributeDefinitionREFSET
	 * DmcTypeAttributeDefinitionREFSTATIC
	 * DmcTypeAttributeDefinitionREFSV
	 * @param od 	The ouput directory.
	 * @param cdef 	The class for which we're dumping the DmcType.
	 * @param LGPL 	The license header.
	 */
	static public void dumpTypeHelpersClass(String od, DMUncheckedObject cdef, String LGPL) throws IOException, DMFeedbackSet {
		// We don't dump the DmcType for unnamed objects
		if (cdef.getSV("isNamedBy") == null)
			return;
		
		dumpDmcType(od, cdef, LGPL);
		
		dumpREF(od, cdef, LGPL);
	}
	
	static private void dumpDmcType(String od, DMUncheckedObject cdef, String LGPL) throws IOException {
		String 			cn 	= cdef.getSV("name");
		BufferedWriter 	out = FileUpdateManager.instance().getWriter(od,"DmcType" + cn + "REF.java");

		out.write(LGPL);
		out.write("package org.dmd.dms.shared.generated.types;\n\n");
		
		ImportManager imports = new ImportManager();
		
		imports.addImport("java.io.Serializable", 							"Marker for serializable");
		imports.addImport("org.dmd.core.schema.DmcAttributeInfo", 			"Required by DmcAttribute ");
		imports.addImport("org.dmd.core.feedback.DMFeedbackSet", 			"To facilitate error handling");
		imports.addImport("org.dmd.core.DmcObjectName", 					"Because we're a named object");
		imports.addImport("org.dmd.core.interfaces.DmcOutputStreamIF", 		"To support serialization");
		imports.addImport("org.dmd.dms.shared.types.DmcTypeNamedObjectREF", "Because we extend this");
		imports.addImport("org.dmd.dms.shared.generated.dmo." + cn + "DMO", "The type of object we refer to");
		imports.addImport("org.dmd.core.interfaces.DmcInputStreamIF", 		"To support serialization");
		imports.addImport("org.dmd.dms.shared.types.DefinitionName", 		"The type of our naming attribute");

		out.write(imports.getFormattedImports() + "\n");

		out.write("/**\n * The DmcType" + cn + "REF class.\n");
		out.write(" * This code was auto-generated by the MetaGen utility and shouldn't be alterred manually.\n");
		out.write(" * Generated from: " + org.dmd.util.runtime.DebugInfo.getWhereWeAreNow()
				+ "\n");
		out.write(" */\n");

		out.write("@SuppressWarnings(\"serial\")\n");
		out.write("abstract public class DmcType" + cn + "REF extends DmcTypeNamedObjectREF<" + cn + "REF, DefinitionName> implements Serializable {\n\n");

		out.write("    /**\n");
		out.write("     * Default constructor.\n");
		out.write("     */\n");
		out.write("    public DmcType" + cn + "REF(){\n");
		out.write("    }\n\n");

		out.write("    /**\n");
		out.write("     * Default constructor.\n");
		out.write("     */\n");
		out.write("    public DmcType" + cn + "REF(DmcAttributeInfo ai){\n");
		out.write("        super(ai);\n");
		out.write("    }\n\n");

		out.write("    /**\n");
		out.write("     * Checks that we have a " + cn + "REF or " + cn + "DMO.\n");
		out.write("     */\n");
		out.write("    public " + cn + "REF typeCheck(Object value) throws DMFeedbackSet {\n");
		out.write("        " + cn + "REF rc = null;\n");
		out.write("        if (value instanceof " + cn + "REF)\n");
		out.write("            rc = (" + cn + "REF)value;\n");
		out.write("        else if (value instanceof " + cn + "DMO)\n");
		out.write("            rc = new " + cn + "REF((" + cn + "DMO)value);\n");
		out.write("        else if (value instanceof DmcObjectName){\n");
		out.write("            rc = new " + cn + "REF();\n");
		out.write("            rc.setName((DmcObjectName)value);\n");
		out.write("        }\n");
		out.write("        else if (value instanceof String){\n");
		out.write("            rc = new " + cn + "REF();\n");
		out.write("            rc.setName(new DefinitionName((String)value));\n");
		out.write("        }\n");
		out.write("        else\n");
		out.write("            throw(new DMFeedbackSet(\"Object of class:\" + value.getClass().getName() + \" passed where a " + cn + "REF/DMO or DmcObjectName expected.\"));\n");
		out.write("        return(rc);\n");
		out.write("    }\n\n");

		out.write("    @Override\n");
		out.write("    protected " + cn + "REF " + "getNewHelper(){\n");
		out.write("        return( new " + cn + "REF());\n");
		out.write("    }\n\n");

		out.write("    @Override\n");
		out.write("    protected DefinitionName " + "getNewName(){\n");
		out.write("        return( new DefinitionName());\n");
		out.write("    }\n\n");

		out.write("    @Override\n");
		out.write("    protected String getDMOClassName(){\n");
		out.write("        return( " + cn + "DMO.class.getName());\n");
		out.write("    }\n\n");

		out.write("    @Override\n");
		out.write("    protected boolean isDMO(Object value){\n");
		out.write("        if (value instanceof " + cn + "DMO)\n");
		out.write("            return(true);\n");
		out.write("        return(false);\n");
		out.write("    }\n\n");

		out.write("    /**\n");
		out.write("     * Returns a clone of a value associated with this type.\n");
		out.write("     */\n");
		out.write("    @Override\n");
		out.write("    public " + cn + "REF cloneValue(" + cn + "REF val){\n");
		out.write("        " + cn + "REF rc = new " + cn + "REF(val);\n");
		out.write("        return(rc);\n");
		out.write("    }\n\n");

		out.write("    @Override\n");
		out.write("    public void serializeValue(DmcOutputStreamIF dos, " + cn + "REF value) throws Exception {\n");
		out.write("        value.serializeIt(dos);\n");
		out.write("    }\n\n");

		out.write("    @Override\n");
		out.write("    public " + cn + "REF deserializeValue(DmcInputStreamIF dis) throws Exception {\n");
		out.write("        " + cn + "REF rc = new " + cn + "REF();\n");
		out.write("        rc.deserializeIt(dis);\n");
		out.write("        return(rc);\n");
		out.write("    }\n\n");

		out.write("}\n");

		out.close();

	}
	
	static private void dumpREF(String od, DMUncheckedObject cdef, String LGPL) throws IOException {
		// Generate the reference container
		String 			cn 	= cdef.getSV("name");

		String nameType = "DefinitionName";
		if (cn.equals("RuleData"))
			nameType = "RuleName";

		BufferedWriter 	out = FileUpdateManager.instance().getWriter(od,cn + "REF.java");

		out.write(LGPL);
		out.write("package org.dmd.dms.shared.generated.types;\n\n");

		ImportManager imports = new ImportManager();
		
		imports.addImport("java.io.Serializable", 							"Marker for serializable");
		imports.addImport("org.dmd.core.DmcAttribute", 						"Used when retrieving the naming attribute");
		imports.addImport("org.dmd.core.feedback.DMFeedbackSet", 			"To facilitate error handling");
		imports.addImport("org.dmd.core.DmcObjectName", 					"Because we're a named object");
		imports.addImport("org.dmd.core.interfaces.DmcOutputStreamIF", 		"To support serialization");
//		imports.addImport("org.dmd.dms.shared.types.DmcTypeNamedObjectREF", "Because we extend this");
		imports.addImport("org.dmd.dms.shared.generated.dmo." + cn + "DMO", "The type of object we refer to");
		imports.addImport("org.dmd.core.interfaces.DmcInputStreamIF", 		"To support serialization");
		imports.addImport("org.dmd.dms.shared.types.DmcType" + nameType, 	"The type of our naming attribute");
		imports.addImport("org.dmd.core.DmcNamedObjectNontransportableREF", "THIS HAS TO CHANGE");
		imports.addImport("org.dmd.dms.shared.generated.dmo.MetaDMSAG", "dark-matter core");

		if (cn.equals("ClassDefinition")) {
			imports.addImport("org.dmd.core.DmcOmni", 		"So that we can get DmcClassInfo");
			imports.addImport("org.dmd.core.schema.DmcClassInfo", 	"So that we can get DmcClassInfo");
		}
		out.write(imports.getFormattedImports() + "\n");

		
		out.write("/**\n * The " + cn + "REF class.\n");
		out.write(" * This code was auto-generated by the createmeta utility and shouldn't be alterred manually\n");
		out.write(" * Generated from: " + DebugInfo.getWhereWeAreNow() + "\n");
		out.write(" */\n");

		out.write("@SuppressWarnings(\"serial\")\n");
		out.write("public class " + cn + "REF extends DmcNamedObjectNontransportableREF<" + cn + "DMO> implements Serializable {\n\n");

		if (cn.equals("ClassDefinition")) {
			out.write("    transient DmcClassInfo info;\n\n");
		}

		out.write("    DmcType" + nameType + " myName;\n\n");

		out.write("    /**\n");
		out.write("     * Default constructor.\n");
		out.write("     */\n");
		out.write("    public " + cn + "REF(){\n");
		out.write("        myName = null;\n");
		out.write("    }\n\n");

		out.write("    /**\n");
		out.write("     * Copy constructor.\n");
		out.write("     */\n");
		out.write("    public " + cn + "REF(" + cn + "REF original){\n");
		out.write("        myName = original.myName;\n");
		out.write("        object = original.object;\n");
		out.write("    }\n\n");

		out.write("    /**\n");
		out.write("     * Wrapper constructor.\n");
		out.write("     */\n");
		out.write("    public " + cn + "REF(" + cn + "DMO dmo){\n");
		out.write("        myName = (DmcType" + nameType + ") dmo.getObjectNameAttribute();\n");
		out.write("        object = dmo;\n");
		out.write("    }\n\n");

		out.write("    /**\n");
		out.write("     * Sets our object.\n");
		out.write("     */\n");
		out.write("    @Override\n");
		out.write("    public void setObject(" + cn + "DMO o){\n");
		out.write("        object = o;\n");
		out.write("    }\n\n");

		out.write("    /**\n");
		out.write("     * Clones this reference.\n");
		out.write("     */\n");

		out.write("    public " + cn + "REF cloneMe(){\n");
		out.write("        " + cn + "REF rc = new " + cn + "REF();\n");
		out.write("        rc.myName = myName;\n");
		out.write("        rc.object = object;\n");
		out.write("        return(rc);\n");
		out.write("    }\n\n");

		out.write("    @Override\n");
		out.write("    public void setName(DmcObjectName n) throws DMFeedbackSet {\n");
		out.write("        if (myName == null);\n");
		out.write("            myName = new  DmcType" + nameType + "SV(MetaDMSAG.__name);\n");
		out.write("        myName.set(n);\n");
		out.write("    }\n\n");

		out.write("    @Override\n");
		out.write("    public DmcAttribute<?> getObjectNameAttribute(){\n");
		out.write("         return(myName);\n");
		out.write("    }\n\n");

		out.write("    @Override\n");
		out.write("    public DmcObjectName getObjectName(){\n");
		out.write("         return(myName.getSV());\n");
		out.write("    }\n\n");

		out.write("    public void serializeIt(DmcOutputStreamIF dos) throws Exception {\n");
		out.write("         myName.serializeIt(dos);\n");
		out.write("         // the object goes nowhere\n");
		out.write("    }\n\n");

		out.write("    public void deserializeIt(DmcInputStreamIF dis) throws Exception {\n");
		out.write("        myName = (DmcType" + nameType + ") dis.getAttributeInstance();\n");
		out.write("        myName.deserializeIt(dis);\n");
		out.write("    }\n\n");

		if (cn.equals("ClassDefinition")) {
			out.write("    public DmcClassInfo getClassInfo() {\n");
			out.write("        if (info == null){\n");
			out.write("            if (myName == null)\n");
			out.write("                throw(new IllegalStateException(\"No name set for a ClassDefinitionREF\"));\n");
			out.write("            info = DmcOmni.instance().getClassInfo(myName.getSV().getNameString());\n");
			out.write("            if (info == null)\n");
			out.write("                throw(new IllegalStateException(\"Unable to retrieve DmcClassInfo for class: \" + myName.getSV().getNameString() + \" ensure that you have loaded the DmcOmni with the appropriate schemas.\"));\n");
			out.write("        }\n");
			out.write("        return(info);\n");
			out.write("    }\n\n");
		}

		out.write("}\n");

		out.close();
	}
	
	static public void dumpEnumTypeHelper(String od, DMUncheckedObject enumdef, String LGPL) throws IOException {
		// Generate the reference container
		String 			cn 	= enumdef.getSV("name");
		
		BufferedWriter out = FileUpdateManager.instance().getWriter(od, "DmcType" + cn + ".java");

		out.write(LGPL);
		out.write("package org.dmd.dms.shared.generated.types;\n\n");

		
		ImportManager imports = new ImportManager();
		
		imports.addImport("java.io.Serializable", 							"Marker for serializable");
		imports.addImport("org.dmd.core.interfaces.DmcOutputStreamIF", 		"To support serialization");
		imports.addImport("org.dmd.core.interfaces.DmcInputStreamIF", 		"To support serialization");

		imports.addImport("org.dmd.core.DmcAttribute", 						"Because we extend this");
		imports.addImport("org.dmd.core.schema.DmcAttributeInfo", 			"Required by DmcAttribute ");
		imports.addImport("org.dmd.core.feedback.DMFeedbackSet", 			"To facilitate error handling");
		
		imports.addImport("org.dmd.dms.shared.generated.enums." + cn, 		"The enum we're wrapping");

		out.write(imports.getFormattedImports() + "\n");

		
		out.write("@SuppressWarnings(\"serial\")\n");

		out.write("/**\n * The DmcType" + cn + " class.\n");
		out.write(" * This code was auto-generated by the createmeta utility and shouldn't be alterred\n");
		out.write(" * manually.\n");
		out.write(" * Generated from: " + DebugInfo.getWhereWeAreNow() + "\n");
		out.write(" */\n");

		out.write("abstract public class DmcType" + cn + " extends DmcAttribute<" + cn + ">" + " implements Serializable {\n\n");

		out.write("    /**\n");
		out.write("     * Default constructor.\n");
		out.write("     */\n");
		out.write("    public DmcType" + cn + "(){\n");
		out.write("    }\n\n");

		out.write("    /**\n");
		out.write("     * Default constructor.\n");
		out.write("     */\n");
		out.write("    public DmcType" + cn + "(DmcAttributeInfo ai){\n");
		out.write("        super(ai);\n");
		out.write("    }\n\n");

		out.write("    protected " + cn + " typeCheck(Object value) throws DMFeedbackSet {\n");
		out.write("        " + cn + " rc = null;\n\n");

		out.write("        if (value instanceof " + cn + "){\n");
		out.write("            rc = (" + cn + ")value;\n");
		out.write("        }\n");

		out.write("        else if (value instanceof String){\n");
		out.write("            rc = " + cn + ".get((String)value);\n");
		out.write("            if (rc == null){\n");
		out.write("                throw(new DMFeedbackSet(\"Value: \" + value.toString() + \" is not a valid " + cn + " value.\"));\n");
		out.write("            }\n");
		out.write("        }\n");
		out.write("        else if (value instanceof Integer){\n");
		out.write("            rc = " + cn + ".get((Integer)value);\n");
		out.write("            if (rc == null){\n");
		out.write("                throw(new DMFeedbackSet(\"Value: \" + value.toString() + \" is not a valid " + cn + " value.\"));\n");
		out.write("            }\n");
		out.write("        }\n");

		out.write("        else{\n");
		out.write("            throw(new DMFeedbackSet(\"Object of class: \" + value.getClass().getName() + \" passed where object compatible with " + cn + " expected.\"));\n");
		out.write("        }\n");

		out.write("        return(rc);\n");
		out.write("    }\n");

		out.write("\n");

		out.write("    /**\n");
		out.write("     * Returns a clone of a value associated with this type.\n");
		out.write("     */\n");
		out.write("    public " + cn + " cloneValue(" + cn + " val){\n");
		out.write("        " + cn + " rc = val;\n");
		out.write("        return(rc);\n");
		out.write("    }\n\n");

		out.write("    /**\n");
		out.write("     * Writes a " + cn + ".\n");
		out.write("     */\n");
		out.write("    @Override\n");
		out.write("    public void serializeValue(DmcOutputStreamIF dos, " + cn + " value) throws Exception {\n");
		out.write("        dos.writeShort(value.intValue());\n");
		out.write("    }\n\n");

		out.write("    /**\n");
		out.write("     * Reads a " + cn + ".\n");
		out.write("     */\n");
		out.write("    @Override\n");
		out.write("    public " + cn + " deserializeValue(DmcInputStreamIF dis) throws Exception {\n");
		out.write("        return(" + cn + ".get(dis.readShort()));\n");
		out.write("    }\n\n");

		out.write("\n");
		out.write("\n");

		out.write("}\n");

		out.close();

	}
}
