//	---------------------------------------------------------------------------
//	dark-matter-data
//	Copyright (c) 2011 dark-matter-data committers
//	---------------------------------------------------------------------------
//	This program is free software; you can redistribute it and/or modify it
//	under the terms of the GNU Lesser General Public License as published by the
//	Free Software Foundation; either version 3 of the License, or (at your
//	option) any later version.
//	This program is distributed in the hope that it will be useful, but WITHOUT
//	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//	FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for
//	more details.
//	You should have received a copy of the GNU Lesser General Public License along
//	with this program; if not, see <http://www.gnu.org/licenses/lgpl.html>.
//	---------------------------------------------------------------------------
package org.dmd.mvw.tools.mvwgenerator.generated.enums;

import java.util.*;

import org.dmd.dmc.DmcEnumIF;

/**
 * The RequestOptionEnum indicates a set of modifiers that direct code
 * generation for standard Dark Matter Protocol request handling.
 * <P>
 * Generated from the mvw schema at version 0.1
 * <P>
 * This code was auto-generated by the dmogenerator utility and shouldn't be altered manually!
 * Generated from: org.dmd.dms.util.DmoEnumFormatter.dumpEnum(DmoEnumFormatter.java:100)
 */
public enum RequestOptionEnum implements DmcEnumIF
{
    NONE(0,"Indicates that no options are specified."),

    DMPERRORS(1,"Indicates that DMP error responses will be handled locally."),

    RPCERRORS(2,"Indicates that RPC errors will be handled locally."),

    CENTRALDMPERRORS(3,"Indicates that you want DMP errors centrally handled."),

    CENTRALRPCERRORS(4,"Indicates that you want RPC errors centrally handled."),

    CENTRALERRORS(5,"Indicates that you want DMP/RPC errors centrally handled."),

    CACHE(6,"Indicates that you want the results centrally cached."),

    EVENTS(7,"Indicates that you want notification of events associated with the get request.");

    // Maps our integer value to the enumeration value
    private static final Map<Integer,RequestOptionEnum> lookup = new HashMap<Integer,RequestOptionEnum>();

    static {
        for(RequestOptionEnum s : EnumSet.allOf(RequestOptionEnum.class))
            lookup.put(s.intValue(), s);
    }

    // Maps our enumeration (string) value to the enumeration value
    private static final Map<String,RequestOptionEnum> lookupString = new HashMap<String, RequestOptionEnum>();

    static {
        for(RequestOptionEnum s : EnumSet.allOf(RequestOptionEnum.class))
            lookupString.put(s.name(), s);
    }

    // Our current value as an int - normally, this isn't available in an enum
    private int ival;

    // Our current display value as a String
    private String dval;

    /**
     * This private constructor allows us to access our int value when required.
     */
    private RequestOptionEnum(int i, String d){
        ival = i;
        dval = d;
    }

    /**
     * Returns the value of this enum value as an int.
     */
    public int intValue(){
        return(ival);
    }

    /**
     * Returns the display value of this enum value as a String.
     */
    public String displayValue(){
        return(dval);
    }

    /**
     * Returns the enum value of the specified int or null if it's not valid.
     */
    public static RequestOptionEnum get(int code) {
        return(lookup.get(code));
    }

    /**
     * Returns a value for this enum or throws an exception if the String value isn't
     * a valid member of this enum.
     */
    public static RequestOptionEnum get(String str) {
        return(lookupString.get(str));
    }

}