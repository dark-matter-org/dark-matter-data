package org.dmd.dms.util;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Iterator;

import org.dmd.dms.EnumDefinition;
import org.dmd.dms.SchemaDefinition;
import org.dmd.dms.types.EnumValue;
import org.dmd.util.exceptions.DebugInfo;
import org.dmd.util.formatting.CodeFormatter;

/**
 * The DmoTypeFormatter will generate the various types associated with schema defined
 * enumerations and the object reference types.
 */
public class DmoEnumFormatter {
	
	PrintStream	progress;

	public DmoEnumFormatter(){
		progress = null;
	}
	
	public DmoEnumFormatter(PrintStream o){
		progress = o;
	}
	
	/**
	 * This method will generate the enum classes for all EnumDefinitions in the
	 * specified schema.
	 * @param sd     The schema.
	 * @param outdir Where to dump the class.
	 * @param ps     A place to print progress if required.
	 * @throws IOException
	 */
	public void dumpEnums(SchemaDefinition sd, String outdir) throws IOException{
		if (progress != null)
			progress.println("");

		Iterator<EnumDefinition> enums = sd.getEnumDefList();
		while(enums.hasNext())
			dumpEnum(enums.next(),outdir);
	}
	
	private void dumpEnum(EnumDefinition ed, String outdir) throws IOException{
		String cn = ed.getName();
		String ofn = outdir + File.separator + cn + ".java";
      	String schemaPackage = ed.getDefinedIn().getSchemaPackage();
		
		BufferedWriter 	out = new BufferedWriter( new FileWriter(ofn) );
      
		if (progress != null){
			progress.println("    Generating " + ofn);
//			progress.println(ed.toOIF(15));
		}
      
        out = new BufferedWriter(new FileWriter(outdir + File.separator + cn + ".java"));

      	out.write("package " + schemaPackage + ".generated.shared.enums;\n\n");

        out.write("import java.util.*;\n\n");

        out.write("/**\n");
        CodeFormatter.dumpCodeComment(ed.getDescription(),out," * ");
        out.write(" * \n");
        out.write(" * This code was auto-generated by the dmogenerator utility and shouldn't be alterred manually!\n");
        out.write(" * Generated from: " + DebugInfo.getWhereWeAreNow() + "\n");
        out.write(" */\n");
        out.write("public enum " + cn + "\n{\n");

        Iterator<EnumValue> enumit = ed.getEnumValue();
        while(enumit.hasNext()){
        	EnumValue ev = enumit.next();
        	
            out.write("    /**\n");
            CodeFormatter.dumpCodeComment(ev.getDescription(),out,"     * ");
            out.write("     */\n");
            
            out.write("    " + ev.getName() + "(" + ev.getId() + ")");
            if (enumit.hasNext())
            	out.write(",\n\n");
            else
            	out.write(";\n\n");
        }
        
        out.write("    // Maps our integer value to the enumeration value\n");
        out.write("    private static final Map<Integer," + cn + "> lookup = new HashMap<Integer," + cn + ">();\n\n");

        out.write("    static {\n");
      	out.write("        for(" + cn + " s : EnumSet.allOf(" + cn + ".class))\n");
      	out.write("            lookup.put(s.intValue(), s);\n");
     	out.write("    }\n\n");
        
        out.write("    // Maps our enumeration (string) value to the enumeration value\n");
        out.write("    private static final Map<String," + cn + "> lookupString = new HashMap<String, " + cn + ">();\n\n");

        out.write("    static {\n");
      	out.write("        for(" + cn + " s : EnumSet.allOf(" + cn + ".class))\n");
      	out.write("            lookupString.put(s.name(), s);\n");
     	out.write("    }\n\n");
        
        out.write("    // Our current value as an int - normally, this isn't available in an enum\n");
        out.write("    private int ival;\n\n");
        
        out.write("    /**\n");
        out.write("     * This private constructor allows us to access our int value when required.\n");
        out.write("     */\n");
        out.write("    private " + cn + "(int i){\n");
        out.write("        ival = i;\n");
        out.write("    }\n\n");
        
        out.write("    /**\n");
        out.write("     * Returns the value of this enum value as an int.\n");
        out.write("     */\n");
        out.write("    public int intValue(){\n");
        out.write("        return(ival);\n");
        out.write("    }\n\n");
        
        out.write("    /**\n");
        out.write("     * Returns the enum value of the specified int or null if it's not valid.\n");
        out.write("     */\n");
        out.write("    public static " + cn + " get(int code) {\n");
        out.write("        return(lookup.get(code));\n"); 
        out.write("    }\n\n");
       
        out.write("    /**\n");
        out.write("     * Returns a value for this enum or throws an exception if the String value isn't\n");
        out.write("     * a valid member of this enum.\n");
        out.write("     */\n");
        out.write("    public static " + cn + " get(String str) {\n");
        out.write("        return(lookupString.get(str));\n");
      	out.write("    }\n\n");
        
        out.write("}");
        out.close();
      
		out.close();
	}
	
}
