ClassDefinition
name 			MvwDefinition
classType   	ABSTRACT
dmdID			1
useWrapperType	EXTENDED
isNamedBy		camelCaseName
must			camelCaseName
must			definedInModule
may         	file
may        		lineNumber
may         	description
description		The MvwDefinition class provide a common base for all MVW definition
 classes.

ClassDefinition
name			Event
classType       STRUCTURAL
dmdID			2
useWrapperType	EXTENDED
derivedFrom		MvwDefinition
isNamedBy		eventName
must			eventName
may             argVector
may				importThis
may				firedInThisModule
description		The specification of an Event definition will result in the creation of
 a gwtEvent and its associated handler interface.


//ClassDefinition
//name			SingleDMOSelectedEvent
//classType       STRUCTURAL
//useWrapperType	EXTENDED
//derivedFrom		BroadcastEvent
//isNamedBy		eventName
//must			eventName
//must			selectedDMO
//description		The SingleDMOSelectedEvent is a BroadcastEvent that indicates that a single 
// Dark Matter Object has been selected, usually in an MvwView component. By defining an event
// of this type, your component will have the event added to its event interface and, when that
// event is fired, the framework will also fire a generic DMO event that is handled by the 
// MvwSelectionManager component. 
//
//ClassDefinition
//name			MultipleDMOSelectedEvent
//classType       STRUCTURAL
//useWrapperType	EXTENDED
//derivedFrom		BroadcastEvent
//isNamedBy		eventName
//must			eventName
//must			selectedDMO
//description		The MultipleDMOSelectedEvent is a BroadcastEvent that indicates that multiple
// DMOs have been selected. As with the single select event, a generic DMO event that is
// handled by the MvwSelectionManager is fired as well.

ClassDefinition
name			Module
classType       STRUCTURAL
dmdID			3
useWrapperType	EXTENDED
derivedFrom		MvwDefinition
isNamedBy		moduleName
must			moduleName
must			genPackage
may				dependsOnModule
may				dependsOnSchema
may				usingStandardSubpackages
description		The Module is used to define a reusable set of MVW functionality which
 can be referred to in Application definitions or other Module definitions. 

ClassDefinition
name			View
classType       STRUCTURAL
dmdID			4
derivedFrom		MvwDefinition
useWrapperType	EXTENDED
isNamedBy		viewName
must			viewName
may				useBaseClass
may				local
may				broadcast
may				broadcastOnly
may				viewImport
may				presenterImport
may				sharedImport
may				subpackage
//
may				usesRunContextItem
//
may				widget
may				extendsInterface
//may				broadcast
//may				broadcastOnly
may				presenterMethod
may				viewMethod
may				displayDMO
may				selectEvent
may				deleteEvent
may				clickEvent
may				modifyEvent
may				createEvent
description		The View is used to define the aspects of two kinds of interfaces that
 define the functionality provided by a view of a model; the event interface and the 
 data interface.

ClassDefinition
name			Component
classType       ABSTRACT
dmdID			5
useWrapperType	EXTENDED
derivedFrom		MvwDefinition
isNamedBy		componentName
must			componentName
may				firesEvent
may				handlesEvent
may				useSchema
may				useBaseClass
may				usesRunContextItem
//may				sendsGetRequest
may				sendsRequest
//may				sendsDeleteRequest
//may				sendsSetRequest
//may				sendsCreateRequest
//may				sendsActionRequest
//may				sendsLoginRequest
//may				sendsLogoutRequest
may				subpackage
may				instantiatesView
description		The Component is an abstract base for classes that define the building blocks
 of Applications. The primary feature of an Component is that it fires and/or handles events.
 Beyond that, a component can be whatever you require it to be. A variety of derived component types
 provide more focussed behavioural units.
 <p />
 Many of the classes generated by MVW must be extended in order to provide the actual
 behaviour of your application e.g. Controllers, Views, Presenters etc. Activities must
 also be extended to provide your behaviour, however, Activities are also referred to
 by generated code and must be in a known location. By default, the classes that extend
 the generated activity class will reside in the 'extended' package that lies beneath the
 genPackage specified for your module i.e. if your gen package is com.mine, then the 
 derived activity classes are expected to be in com.mine.extended. If you want to place
 these classes in a subpackage beneath extended, use the subpackage attribute to indicate
 the package name e.g. if subpackage is defined as 'activities', your activity implementation
 class will be expected to reside in com.mine.extended.activities.

ClassDefinition
name			Controller
classType       STRUCTURAL
dmdID			6
useWrapperType	EXTENDED
derivedFrom		Component
isNamedBy		controllerName
must			controllerName
may				centralDMPErrorHandler
may				centralRPCErrorHandler
may				centralAsyncErrorHandler
may				addedToRunContext
may				instantiatesPresenter
may				itemOrder
may				implementsAction
description		The Controller represents a behavioural component that lives throughout
 the entire lifecycle of an WebApplication or WebSite. Generally, it manages the Presenters
 and Views that are displayed, but may also provide behind the scenes management of things
 like communications, security, menu structure etc. Controllers do not implement Presenter
 interfaces i.e. they do not interact directly with Views; that is the role of Presenters.
 <p />
 Because of their implied lifetime, Controllers are made part of the overall RunContext for
 an application and are constructed during initialization of the application. There is no
 need to instantiate Controllers separately. The RunContextItem created for a controller
 has the same name as the Controller itself with RCI appended. You may specify an itemOrder
 for the Controller to control when it is instantiated in the RunContext; use this option
 only if you know what you're doing! The default itemOrder is 50, most base related functionality
 starts in itemOrder 20 or lower.
 <p />
 Controllers should not communicate with other Controllers directly; this type of communication
 should be performed using events. So, although it is possible to get the handle to another
 Controller via the RunContext, it is discouraged.
 <p />
 

ClassDefinition
name			Presenter
classType       STRUCTURAL
dmdID			7
useWrapperType	EXTENDED
derivedFrom		Component
isNamedBy		presenterName
must			presenterName
must			managesView
may				codeSplit
may				singleton
may				instantiatesPresenter
description		The Presenter is a behavioural component that manages one or more Views and
 thus implements the Presenter interface of any View it manages. Presenters populate and
 potentially update Views with data. This will often involve interacting with the communications
 interface(s) associated with an application. If a View allows the creation or alteration
 of data, those behaviours are usually handled directly by the View's Presenter.

//ClassDefinition
//name			DefaultPlace
//classType       STRUCTURAL
//useWrapperType	EXTENDED
//derivedFrom		MvwDefinition
//isNamedBy		placeName
//must			placeName
//may				placePrefix
//must			runsActivity

ClassDefinition
name			Place
classType       STRUCTURAL
dmdID			8
useWrapperType	EXTENDED
derivedFrom		MvwDefinition
isNamedBy		placeName
must			placeName
must			placePrefix
must			runsActivity

ClassDefinition
name			SubPlace
classType       STRUCTURAL
dmdID			9
useWrapperType	EXTENDED
derivedFrom		Place
isNamedBy		placeName
must			placeName
must			placePrefix
must			parentPlace

ClassDefinition
name			Activity
classType       STRUCTURAL
dmdID			10
useWrapperType	EXTENDED
derivedFrom		Component
isNamedBy		activityName
must			activityName
may				useBaseClass
may				abstractActivity
may				usesController
may				managesView
may				instantiatesPresenter
may				codeSplit
description		If you are making use of Places, you'll define an Activity for
 each of them; all activities are derived from com.google.gwt.app.place.Activity. If you
 have common functionality that you wish to use for your Activity classes, implement
 it in a class derived from com.google.gwt.app.place.Activity and specify that class
 in the useBaseClass attribute of your defined Activity.
 <p />
 Activities are meant to be short-lived, disposable entities that run in a particular Place.
 However, if you are building an application, it may be that you have a single Place and
 that all behaviour takes place within the guise of a single Activity.
 <p />
 If the Activity manages a view, it will be generated as implementing the View's 
 presenter interface.
 <p/>
 Activities provide a natural division point for GWT code splitting, if you've structured your
 code appropriately. By specifying the codeSplit flag as true, the code for the Activity will be 
 asynchronously loaded using the GWT code splitting mechanisms.
// <a href="https://developers.google.com/web-toolkit/doc/latest/DevGuideCodeSplitting">
// GWT code splitting mechanisms.</a>

ClassDefinition
name			RunContextItem
classType		STRUCTURAL
dmdID			11
derivedFrom		MvwDefinition
useWrapperType	EXTENDED
isNamedBy		itemName
must			itemName
must			useClass
must			construction
may				itemOrder
may				contextImpl
may				importThis
may				createOnDemand
may				singleton
may				autoCreated
description		The RunContextItem allows for the generation of an overall RunContext for
 a WebApplication or WebSite.
 
ClassDefinition
name			WebApplication
classType		STRUCTURAL
dmdID			12
derivedFrom		MvwDefinition
useWrapperType	EXTENDED
isNamedBy		appName
must			appName
must			defaultPlace
may				usesController
may				menuImplementation
description		The WebApplication definition allows for the definition of the superstructure
 for an application, basically it's the definition of the overall application controller. 

ClassDefinition
name			I18NConfig
classType		STRUCTURAL
dmdID			14
derivedFrom		RunContextItem
useWrapperType	EXTENDED
isNamedBy		itemName
must			itemName
description		The I18NConfig is a specialized RunContextItem that indicates an interface
 class used to access internationalized constants or messages.

ClassDefinition
name			MenuImplementationConfig
classType		STRUCTURAL
subpackage		menus
dmdID			15
derivedFrom		MvwDefinition
useWrapperType	EXTENDED
isNamedBy		configName
must			configName
must			useClass
must			defaultMenuBar
must			defaultSubMenu
must			defaultMenuItem
must			defaultSeparator
may				alternateMenuBar
may				alternateSubMenu
may				alternateMenuItem
description		The MenuImplementationConfig is used to define the various classes that will 
 be used to implement an actual menu structure based the MVW menu definitions.
 <p />
 The class specified by useClass must be derived from org.dmd.mvw.client.mvwmenus.base.MvwMenuFactory
 and have a zero arg constructor.

ClassDefinition
name			MenuElementDefinition
classType		STRUCTURAL
subpackage		menus
dmdID			16
derivedFrom		MvwDefinition
isNamedBy		elementName
must			elementName
may				useImpl
description		The MenuElementDefinition is common base for all definitions associated with
 the definition of menu elements.

ClassDefinition
name			Menu
classType		ABSTRACT
subpackage		menus
dmdID			17
derivedFrom		MenuElementDefinition
useWrapperType	EXTENDED
isNamedBy		elementName
must			elementName
description		The Menu is a common base for all definitions associated with
 the definition of menus of different types e.g. toolbars, menubars, popups etc.

ClassDefinition
name			MenuBar
classType		STRUCTURAL
subpackage		menus
dmdID			18
derivedFrom		Menu
useWrapperType	EXTENDED
isNamedBy		elementName
must			elementName
may				useImpl
description		The MenuImplementationConfig is used to define the various classes that will 

ClassDefinition
name			SubMenu
classType		STRUCTURAL
subpackage		menus
dmdID			19
derivedFrom		Menu
useWrapperType	EXTENDED
isNamedBy		elementName
must			elementName
must			addToMenu
must			menuOrder
may            	displayLabel
may				displayLabelI18N
may				useImpl
description		The SubMenu is used to define a submenu that is included as part of a Menu.

ClassDefinition
name			MenuItem
classType		STRUCTURAL
subpackage		menus
dmdID			20
derivedFrom		MenuElementDefinition
useWrapperType	EXTENDED
isNamedBy		elementName
must			elementName
must			triggersAction
must			addToMenu
must			menuOrder
may             displayLabel
may				displayLabelI18N
may				useImpl
description		The MenuItem is used to define triggerable menu items. You must specify
 either a displayLabel or a displayLabelI18N to indicate the label to be used for the
 menu item.

ClassDefinition
name			Separator
classType		STRUCTURAL
subpackage		menus
dmdID			21
derivedFrom		MenuElementDefinition
useWrapperType	EXTENDED
isNamedBy		elementName
must			elementName
must			addToMenu
must			menuOrder
may				useImpl
description		The Separator is used to define menu separators.

ClassDefinition
name			ActionBinding
classType		STRUCTURAL
subpackage		menus
dmdID			22
derivedFrom		MvwDefinition
useWrapperType	EXTENDED
isNamedBy		actionBindingName
must			actionBindingName
may				implementedBy
description		The ActionBinding class allows for the definition of an intermediate component that binds
 behavioural triggers e.g. menu items, toolbar buttons etc. to action implementors e.g. Controllers,
 Presenters and Activities. The ActionBinding serves the same purpose as the com.google.gwt.user.client.Command
 interface, but provides some additional useful functionality. The implementation of the ActionBinding (see
 org.dmd.mvw.client.mvwmenus.base.ActionBinding) maintains a set of TriggerIF interfaces, which are the various
 implementations of the menu items, toolbar buttons etc. An implementing component can enable/disable its
 Actions which, in turn, can enable/disable its triggers.

ClassDefinition
name			FormBindingDefinition
classType		STRUCTURAL
subpackage		forms
dmdID			23
derivedFrom		MvwDefinition
useWrapperType	EXTENDED
isNamedBy		bindingName
may				strictlyChecked
must			bindingName
must			editObject
must			editField
may				useI18NConfig
may				tipsFromI18N
description		The FormBinding class allows for the definition of bindings between DMO attributes
 and the editors that will be used to display and edit their values. 

ClassDefinition
name			FieldEditorDefinition
classType		STRUCTURAL
subpackage		forms
dmdID			24
derivedFrom		MvwDefinition
useWrapperType	EXTENDED
isNamedBy		editorName
must			editorName
must			useClass
may				useSingleEditor
description		The FieldEditor class allows for the definition of implementation specific field
 editors. The specified class must implement the org.dmd.dmc.DmcPresentationIF
 interface so that it can be initialized by the FormBinder that is generated for each FormBindingDefinition
 instance and so that it can interact with the AttributeTracker and the SetRequestGenerator.
 <p/>
 When dealing with indexed attributes, the default behaviour is to create a
 form binding with an editor instance for each index slot. However, in some cases, you
 want to use a single complex editor that handles the attribute. By setting useSingleEditor
 to true, the form binding will contain a single editor for an indexed attribute.

ClassDefinition
name			FormImplementationConfig
classType		STRUCTURAL
subpackage		forms
dmdID			25
derivedFrom		MvwDefinition
useWrapperType	EXTENDED
isNamedBy		configName
must			configName
//may				mandatoryStyle
description		The  

ClassDefinition
name			GxtEnumMapping
classType		STRUCTURAL
subpackage		forms
dmdID			26
derivedFrom		MvwDefinition
useWrapperType	EXTENDED
isNamedBy		mappingName
must			mappingName
must			enumName
must			unsetValue
may				useNameAsLabel
may				skipEnumValue
description		The GxtEnumMapping class allows for generation of a set of static data instances
 that represent the values from the specified enumeration (type). NOTE: this mechanism is only 
 useful if you are using the Sencha's GXT widget set.
 <p />
 Enum values are comprised of an integer, a name, a description and optionally, a label as follows - int name description : label.
 If you specify useNameAsLabel, the uppercase name value of the enum is used to display the value
 of the. If useNameAsLabel is not specified, the label will be used if it has been specified. Otherwise,
 the description is used.
 

